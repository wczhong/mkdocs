<!DOCTYPE html>
<html lang="en" data-bs-theme="light">
    <head>
        <meta charset="utf-8">
        <meta http-equiv="X-UA-Compatible" content="IE=edge">
        <meta name="viewport" content="width=device-width, initial-scale=1.0">
        
        
        <link rel="canonical" href="https://kafka.apachecn.org/1/">
        <link rel="shortcut icon" href="../img/favicon.ico">
        <title>1. 入门 - 【布客】kafka 中文翻译</title>
        <link href="../css/bootstrap.min.css" rel="stylesheet">
        <link href="../css/fontawesome.min.css" rel="stylesheet">
        <link href="../css/brands.min.css" rel="stylesheet">
        <link href="../css/solid.min.css" rel="stylesheet">
        <link href="../css/v4-font-face.min.css" rel="stylesheet">
        <link href="../css/base.css" rel="stylesheet">
        <link id="hljs-light" rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.8.0/styles/github.min.css" >
        <link id="hljs-dark" rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.8.0/styles/github-dark.min.css" disabled>
        <script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.8.0/highlight.min.js"></script>
        <script>hljs.highlightAll();</script>
        <script async src="https://www.googletagmanager.com/gtag/js?id=G-8DP4GX97XY"></script>
        <script>
          window.dataLayer = window.dataLayer || [];
          function gtag(){dataLayer.push(arguments);}
          gtag('js', new Date());

          gtag('config', "G-8DP4GX97XY");
        </script> 
    </head>

    <body>
        <div class="navbar fixed-top navbar-expand-lg navbar-dark bg-primary">
            <div class="container">
                <a class="navbar-brand" href="..">【布客】kafka 中文翻译</a>
                <!-- Expander button -->
                <button type="button" class="navbar-toggler" data-bs-toggle="collapse" data-bs-target="#navbar-collapse" aria-controls="navbar-collapse" aria-expanded="false" aria-label="Toggle navigation">
                    <span class="navbar-toggler-icon"></span>
                </button>

                <!-- Expanded navigation -->
                <div id="navbar-collapse" class="navbar-collapse collapse">
                        <!-- Main navigation -->
                        <ul class="nav navbar-nav">
                            <li class="nav-item">
                                <a href=".." class="nav-link">kafke 中文文档</a>
                            </li>
                            <li class="nav-item">
                                <a href="https://kafka1x.apachecn.org" class="nav-link">kafke 1.0.x 版本</a>
                            </li>
                            <li class="nav-item dropdown">
                                <a href="#" class="nav-link dropdown-toggle active" aria-current="page" role="button" data-bs-toggle="dropdown"  aria-expanded="false">kafke 3.5.x 版本</a>
                                <ul class="dropdown-menu">
                                    
<li>
    <a href="./" class="dropdown-item active" aria-current="page">1. 入门</a>
</li>
                                    
<li>
    <a href="../2/" class="dropdown-item">2. APIs</a>
</li>
                                    
<li>
    <a href="../3/" class="dropdown-item">3. 配置</a>
</li>
                                    
<li>
    <a href="../4/" class="dropdown-item">4. 设计</a>
</li>
                                    
<li>
    <a href="../5/" class="dropdown-item">5. 实施</a>
</li>
                                    
<li>
    <a href="../6/" class="dropdown-item">6. 运维</a>
</li>
                                    
<li>
    <a href="../7/" class="dropdown-item">7. 安全</a>
</li>
                                    
<li>
    <a href="../8/" class="dropdown-item">8. Kafka 连接</a>
</li>
                                    
<li>
    <a href="../9/" class="dropdown-item">9. Kafka Streams</a>
</li>
                                </ul>
                            </li>
                            <li class="nav-item">
                                <a href="../downloads/" class="nav-link">下载 Kafka</a>
                            </li>
                            <li class="nav-item">
                                <a href="../contrib/" class="nav-link">贡献指南</a>
                            </li>
                            <li class="nav-item">
                                <a href="https://www.apachecn.org/about" class="nav-link">关于我们</a>
                            </li>
                            <li class="nav-item">
                                <a href="https://www.apachecn.org/join" class="nav-link">加入我们</a>
                            </li>
                            <li class="nav-item">
                                <a href="https://docs.apachecn.org" class="nav-link">中文资源合集</a>
                            </li>
                        </ul>

                    <ul class="nav navbar-nav ms-md-auto">
                        <li class="nav-item">
                            <a href="#" class="nav-link" data-bs-toggle="modal" data-bs-target="#mkdocs_search_modal">
                                <i class="fa fa-search"></i> Search
                            </a>
                        </li>
                            <li class="nav-item">
                                <a rel="prev" href=".." class="nav-link">
                                    <i class="fa fa-arrow-left"></i> Previous
                                </a>
                            </li>
                            <li class="nav-item">
                                <a rel="next" href="../2/" class="nav-link">
                                    Next <i class="fa fa-arrow-right"></i>
                                </a>
                            </li>
                            <li class="nav-item">
                                <a href="https://github.com/apachecn/kafka-doc-zh/edit/master/docs/1.md" class="nav-link">Edit on apachecn/kafka-doc-zh
                                    </a>
                            </li>
                    </ul>
                </div>
            </div>
        </div>

        <div class="container">
            <div class="row">
                    <div class="col-md-3"><div class="navbar-expand-md bs-sidebar hidden-print affix" role="complementary">
    <div class="navbar-header">
        <button type="button" class="navbar-toggler collapsed" data-bs-toggle="collapse" data-bs-target="#toc-collapse" title="Table of Contents">
            <span class="fa fa-angle-down"></span>
        </button>
    </div>

    
    <div id="toc-collapse" class="navbar-collapse collapse card bg-body-tertiary">
        <ul class="nav flex-column">
            
            <li class="nav-item" data-bs-level="1"><a href="#1" class="nav-link">1. 入门</a>
              <ul class="nav flex-column">
            <li class="nav-item" data-bs-level="2"><a href="#11" class="nav-link">1.1 简介</a>
              <ul class="nav flex-column">
              </ul>
            </li>
            <li class="nav-item" data-bs-level="2"><a href="#12" class="nav-link">1.2 使用案例</a>
              <ul class="nav flex-column">
              </ul>
            </li>
            <li class="nav-item" data-bs-level="2"><a href="#13" class="nav-link">1.3 快速入门</a>
              <ul class="nav flex-column">
              </ul>
            </li>
            <li class="nav-item" data-bs-level="2"><a href="#14" class="nav-link">1.4 生态系统</a>
              <ul class="nav flex-column">
              </ul>
            </li>
            <li class="nav-item" data-bs-level="2"><a href="#15" class="nav-link">1.5 旧版本升级</a>
              <ul class="nav flex-column">
              </ul>
            </li>
              </ul>
            </li>
        </ul>
    </div>
</div></div>
                    <div class="col-md-9" role="main">

<h1 id="1">1. 入门</h1>
<h2 id="11">1.1 简介</h2>
<h3 id="_1">什么是事件流？</h3>
<p>事件流相当于人体中枢神经系统的数字化。它是“永远在线”世界的技术基础，在这个世界中，企业越来越多地由软件定义和自动化，软件的用户更多地是软件。</p>
<p>从技术上讲，事件流是以事件流的形式从数据库、传感器、移动设备、云服务和软件应用程序等事件源实时捕获数据的实践；持久存储这些事件流以供以后检索；实时和回顾性地操作、处理事件流并对其做出反应；并根据需要将事件流路由到不同的目标技术。因此，事件流可确保数据的连续流动和解释，以便正确的信息在正确的时间出现在正确的地点。</p>
<h3 id="_2">我可以使用事件流做什么？</h3>
<p>事件流适用于 众多行业和组织的<a href="https://kafka.apache.org/powered-by">各种用例</a>。它的许多例子包括：</p>
<ul>
<li>实时处理支付和金融交易，例如在证券交易所、银行和保险中。</li>
<li>实时跟踪和监控汽车、卡车、车队和货运，例如物流和汽车行业。</li>
<li>持续捕获和分析来自物联网设备或其他设备（例如工厂和风电场）的传感器数据。</li>
<li>收集客户互动和订单并立即做出反应，例如零售、酒店和旅游业以及移动应用程序。</li>
<li>监测医院护理中的患者并预测病情变化，以确保在紧急情况下及时得到治疗。</li>
<li>连接、存储并提供公司不同部门生成的数据。</li>
<li>作为数据平台、事件驱动架构和微服务的基础。</li>
</ul>
<h3 id="apache-kafka">Apache Kafka® 是一个事件流平台。这意味着什么？</h3>
<p>Kafka 结合了三个关键功能，因此您可以使用 一个经过实战检验的解决方案来实现端到端事件流的 <a href="https://kafka.apache.org/powered-by">用例：</a></p>
<ol>
<li><strong>发布</strong>（写入）和<strong>订阅</strong>（读取）事件流，包括从其他系统持续导入/导出数据。</li>
<li>根据需要持久可靠地<strong>存储</strong>事件流。</li>
<li>在事件发生时或回顾性地<strong>处理</strong>事件流。</li>
</ol>
<p>所有这些功能都是以分布式、高度可扩展、弹性、容错和安全的方式提供的。Kafka 可以部署在裸机硬件、虚拟机和容器上，也可以部署在本地和云端。您可以选择自行管理 Kafka 环境，也可以选择使用各种供应商提供的完全托管服务。</p>
<h3 id="kafka">简而言之，Kafka 是如何工作的？</h3>
<p>Kafka是一个分布式系统，由通过高性能<a href="https://kafka.apache.org/protocol.html">TCP网络协议进行通信的</a><strong>服务器</strong>和<strong>客户端</strong>组成。它可以部署在本地和云环境中的裸机硬件、虚拟机和容器上。</p>
<p><strong>服务器</strong>：Kafka 作为一台或多台服务器的集群运行，可以跨越多个数据中心或云区域。其中一些服务器形成存储层，称为代理。其他服务器运行 <a href="https://kafka.apache.org/documentation/#connect">Kafka Connect</a>以持续导入和导出数据作为事件流，以将 Kafka 与您现有的系统（例如关系数据库以及其他 Kafka 集群）集成。为了让您实现关键任务用例，Kafka 集群具有高度可扩展性和容错性：如果其中任何服务器发生故障，其他服务器将接管其工作，以确保连续运行而不会丢失任何数据。</p>
<p><strong>客户端</strong>：它们允许您编写分布式应用程序和微服务，即使在网络问题或机器故障的情况下，也可以以容错的方式并行、大规模地读取、写入和处理事件流。Kafka 附带了一些此类客户端，并由 Kafka 社区提供的<a href="https://cwiki.apache.org/confluence/display/KAFKA/Clients">数十个客户端</a>进行了扩充：客户端可用于 Java 和 Scala，包括更高级别的 <a href="https://kafka.apache.org/documentation/streams/">Kafka Streams</a>库，适用于 Go、Python、C/C++ 和许多其他编程语言以及 REST API。</p>
<h3 id="_3">主要概念和术语</h3>
<p>事件记录了世界上或您的企业中“发生了一些<strong>事情</strong>”的事实。在文档中也称为记录或消息。当您向 Kafka 读取或写入数据时，您以事件的形式执行此操作。从概念上讲，事件具有键、值、时间戳和可选的元数据标头。这是一个示例事件：</p>
<ul>
<li>Event key: "Alice"</li>
<li>Event value: "Made a payment of $200 to Bob"</li>
<li>Event timestamp: "Jun. 25, 2020 at 2:06 p.m."</li>
</ul>
<p><strong>生产者</strong>是将事件发布（写入）到 Kafka 的客户端应用程序，而<strong>消费者</strong>是订阅（读取和处理）这些事件的客户端应用程序。在 Kafka 中，生产者和消费者彼此完全解耦且互不可知，这是实现 Kafka 闻名的高可扩展性的关键设计元素。例如，生产者永远不需要等待消费者。Kafka 提供了各种<a href="https://kafka.apache.org/documentation/#semantics">保证</a>，例如一次性处理事件的能力。</p>
<p>事件被组织并持久存储在<strong>主题</strong>中。非常简单，主题类似于文件系统中的文件夹，事件是该文件夹中的文件。示例主题名称可以是“付款”。Kafka 中的主题始终是多生产者和多订阅者：一个主题可以有零个、一个或多个向其写入事件的生产者，以及零个、一个或多个订阅这些事件的消费者。主题中的事件可以根据需要随时读取——与传统消息传递系统不同，事件在使用后不会被删除。相反，您可以通过每个主题的配置设置来定义 Kafka 应保留事件的时间，之后旧事件将被丢弃。Kafka 的性能在数据大小方面实际上是恒定的，因此长时间存储数据是完全可以的。</p>
<p>主题是<strong>分区的</strong>，这意味着一个主题分布在位于不同 Kafka 代理上的多个“桶”中。这种数据的分布式放置对于可扩展性非常重要，因为它允许客户端应用程序同时从多个代理读取数据或向多个代理写入数据。当新事件发布到主题时，它实际上会附加到主题的分区之一。具有相同事件键（例如，客户或车辆 ID）的事件被写入同一分区，并且 Kafka<a href="https://kafka.apache.org/documentation/#semantics">保证</a>给定主题分区的任何消费者将始终按照与写入的顺序完全相同的顺序读取该分区的事件。</p>
<p><img alt="" src="https://kafka.apache.org/images/streams-and-tables-p1_p4.png" /></p>
<p>图：此示例主题有四个分区 P1–P4。两个不同的生产者客户端通过网络将事件写入主题的分区，相互独立地向主题发布新事件。具有相同键（在图中用颜色表示）的事件将写入同一分区。请注意，如果合适，两个生产者都可以写入同一分区。</p>
<p>为了使您的数据具有容错性和高可用性，每个主题都可以<strong>复制</strong>，甚至可以跨地理区域或数据中心进行复制，因此始终有多个代理拥有数据副本，以防出现问题时，您希望对broker进行维护等等。常见的生产设置是复制因子为 3，即始终存在数据的三个副本。此复制是在主题分区级别执行的。</p>
<p>这本入门读物对于介绍来说应该足够了。<a href="https://kafka.apache.org/documentation/#design">如果您有兴趣，文档的设计</a>部分详细解释了 Kafka 的各种概念。</p>
<h3 id="kafka-api">Kafka API</h3>
<p>除了用于管理和管理任务的命令行工具之外，Kafka 还有五个适用于 Java 和 Scala 的核心 API：</p>
<ul>
<li>用于管理和检查主题、代理和其他 Kafka 对象的 <a href="https://kafka.apache.org/documentation.html#adminapi">管理 API</a> 。</li>
<li>Producer <a href="https://kafka.apache.org/documentation.html#producerapi">API，</a>用于将事件流发布（写入）到一个或多个 Kafka 主题。</li>
<li>Consumer <a href="https://kafka.apache.org/documentation.html#consumerapi">API</a>用于订阅（读取）一个或多个主题并处理为其生成的事件流。</li>
<li>Kafka <a href="https://kafka.apache.org/documentation/streams">Streams API</a>用于实现流处理应用程序和微服务。它提供了更高级别的函数来处理事件流，包括转换、有状态操作（例如聚合和连接）、窗口、基于事件时间的处理等等。从一个或多个主题读取输入，以便生成一个或多个主题的输出，从而有效地将输入流转换为输出流。</li>
<li>Kafka <a href="https://kafka.apache.org/documentation.html#connect">Connect API</a>用于构建和运行可重用的数据导入/导出连接器，这些连接器消耗（读取）或生成（写入）来自外部系统和应用程序的事件流，以便它们可以与 Kafka 集成。例如，关系数据库（如 PostgreSQL）的连接器可能会捕获对一组表的每个更改。然而，在实践中，您通常不需要实现自己的连接器，因为 Kafka 社区已经提供了数百个现成的连接器。</li>
</ul>
<h3 id="_4">从这往哪儿走</h3>
<ul>
<li>要获得 Kafka 的实践经验，请按照<a href="https://kafka.apache.org/quickstart">快速入门</a>进行操作。</li>
<li>要更详细地了解 Kafka，请阅读<a href="https://kafka.apache.org/documentation/">文档</a>。您还可以选择<a href="https://kafka.apache.org/books-and-papers">Kafka书籍和学术论文</a>。</li>
<li>浏览<a href="https://kafka.apache.org/powered-by">用例，</a>了解我们全球社区中的其他用户如何从 Kafka 中获取价值。</li>
<li>加入<a href="https://kafka.apache.org/events">当地的 Kafka 聚会小组</a>， 观看Kafka 社区主要会议 <a href="https://kafka-summit.org/past-events/">Kafka Summit 的演讲。</a></li>
</ul>
<h2 id="12">1.2 使用案例</h2>
<p>以下是 Apache Kafka® 的一些流行用例的描述。有关其中一些正在实施的领域的概述，请参阅<a href="https://engineering.linkedin.com/distributed-systems/log-what-every-software-engineer-should-know-about-real-time-datas-unifying/">此博客文章</a>。</p>
<h3 id="_5">消息传递</h3>
<p>Kafka 可以很好地替代更传统的消息代理。使用消息代理的原因有多种（将处理与数据生产者分离、缓冲未处理的消息等）。与大多数消息系统相比，Kafka 具有更好的吞吐量、内置分区、复制和容错能力，这使其成为大规模消息处理应用程序的良好解决方案。</p>
<p>根据我们的经验，消息传递的使用通常吞吐量相对较低，但可能需要较低的端到端延迟，并且通常依赖于 Kafka 提供的强大的持久性保证。</p>
<p>在这个领域，Kafka 可以与<a href="http://activemq.apache.org/">ActiveMQ</a>或 <a href="https://www.rabbitmq.com/">RabbitMQ</a>等传统消息系统相媲美。</p>
<h3 id="_6">网站活动跟踪</h3>
<p>Kafka 的最初用例是能够将用户活动跟踪管道重建为一组实时发布-订阅源。这意味着站点活动（页面浏览、搜索或用户可能执行的其他操作）将发布到中心主题，每种活动类型一个主题。这些源可用于一系列用例的订阅，包括实时处理、实时监控以及加载到 Hadoop 或离线数据仓库系统中以进行离线处理和报告。</p>
<p>活动跟踪的量通常非常大，因为每个用户页面视图都会生成许多活动消息。</p>
<h3 id="_7">指标</h3>
<p>Kafka常用于运行监控数据。这涉及聚合来自分布式应用程序的统计数据以生成集中的操作数据源。</p>
<h3 id="_8">日志聚合</h3>
<p>许多人使用 Kafka 作为日志聚合解决方案的替代品。日志聚合通常从服务器收集物理日志文件，并将它们放在一个中心位置（可能是文件服务器或 HDFS）进行处理。Kafka 抽象了文件的详细信息，并将日志或事件数据作为消息流提供了更清晰的抽象。这可以实现更低延迟的处理，并更轻松地支持多个数据源和分布式数据消费。与 Scribe 或 Flume 等以日志为中心的系统相比，Kafka 提供同样良好的性能、由于复制而提供更强的持久性保证以及更低的端到端延迟。</p>
<h3 id="_9">流处理</h3>
<p>Kafka 的许多用户在由多个阶段组成的处理管道中处理数据，其中原始输入数据从 Kafka 主题中消费，然后聚合、丰富或以其他方式转换为新主题以供进一步消费或后续处理。例如，用于推荐新闻文章的处理管道可能会从 RSS 源中抓取文章内容并将其发布到“文章”主题；进一步处理可能会规范化或删除重复内容，并将清理后的文章内容发布到新主题；最后的处理阶段可能会尝试向用户推荐该内容。此类处理管道根据各个主题创建实时数据流图。从0.10.0.0开始，一个轻量级但功能强大的流处理库，称为<a href="https://kafka.apache.org/documentation/streams">Kafka Streams</a> Apache Kafka 中可以执行上述数据处理。除了 Kafka Streams 之外，替代的开源流处理工具还包括<a href="https://storm.apache.org/">Apache Storm</a>和 <a href="http://samza.apache.org/">Apache Samza</a>。</p>
<h3 id="_10">事件溯源</h3>
<p><a href="http://martinfowler.com/eaaDev/EventSourcing.html">事件溯源</a>是一种应用程序设计风格，其中状态更改被记录为按时间排序的记录序列。Kafka 对非常大的存储日志数据的支持使其成为以此风格构建的应用程序的出色后端。</p>
<h3 id="_11">提交日志</h3>
<p>Kafka 可以充当分布式系统的一种外部提交日志。日志有助于在节点之间复制数据，并充当故障节点恢复数据的重新同步机制。<a href="https://kafka.apache.org/documentation.html#compaction">Kafka 中的日志压缩</a>功能有助于支持这种用法。在这种用法中，Kafka 类似于<a href="https://bookkeeper.apache.org/">Apache BookKeeper</a>项目。</p>
<h2 id="13">1.3 快速入门</h2>
<h3 id="1-kafka">第 1 步：获取Kafka</h3>
<p><a href="https://www.apache.org/dyn/closer.cgi?path=/kafka/3.5.0/kafka_2.13-3.5.0.tgz">下载</a> 最新的 Kafka 版本并解压：</p>
<pre><code class="language-bash">$ tar -xzf kafka_2.13-3.5.0.tgz
$ cd kafka_2.13-3.5.0
</code></pre>
<h3 id="2-kafka">第 2 步：启动KAFKA环境</h3>
<p>注意：您的本地环境必须安装 Java 8+。</p>
<p>Apache Kafka 可以使用 ZooKeeper 或 KRaft 启动。要开始使用任一配置，请按照以下部分之一进行操作，但不能同时进行这两个部分的操作。</p>
<h4 id="kafka_1">Kafka与动物园管理员</h4>
<p>运行以下命令以便以正确的顺序启动所有服务：</p>
<pre><code class="language-bash"># Start the ZooKeeper service
$ bin/zookeeper-server-start.sh config/zookeeper.properties
</code></pre>
<p>打开另一个终端会话并运行：</p>
<pre><code class="language-bash"># Start the Kafka broker service
$ bin/kafka-server-start.sh config/server.properties
</code></pre>
<p>所有服务成功启动后，您将拥有一个正在运行并可供使用的基本 Kafka 环境。</p>
<h4 id="kafka-kraft">Kafka与 Kraft</h4>
<p>生成集群 UUID</p>
<pre><code class="language-bash">$ KAFKA_CLUSTER_ID=&quot;$(bin/kafka-storage.sh random-uuid)&quot;
</code></pre>
<p>设置日志目录格式</p>
<pre><code class="language-bash">$ bin/kafka-storage.sh format -t $KAFKA_CLUSTER_ID -c config/kraft/server.properties
</code></pre>
<p>启动Kafka服务器</p>
<pre><code class="language-bash">$ bin/kafka-server-start.sh config/kraft/server.properties
</code></pre>
<p>一旦 Kafka 服务器成功启动，您将拥有一个正在运行并可供使用的基本 Kafka 环境。</p>
<h3 id="3">第 3 步：创建一个主题来存储您的事件</h3>
<p>Kafka 是一个分布式<em>事件流平台</em>，可让您跨多台机器读取、写入、存储和处理 <a href="https://kafka.apache.org/documentation/#messages"><em>事件</em></a>（在文档中 也称为<em>记录</em>或 <em>消息）。</em></p>
<p>示例事件包括支付交易、手机的地理位置更新、运输订单、物联网设备或医疗设备的传感器测量等等。这些事件被组织并存储在 <a href="https://kafka.apache.org/documentation/#intro_concepts_and_terms"><em>主题</em></a>中。非常简单，主题类似于文件系统中的文件夹，事件是该文件夹中的文件。</p>
<p>因此，在编写第一个事件之前，您必须创建一个主题。打开另一个终端会话并运行：</p>
<pre><code class="language-bash">$ bin/kafka-topics.sh --create --topic quickstart-events --bootstrap-server localhost:9092
</code></pre>
<p>所有 Kafka 的命令行工具都有附加选项：运行<code>kafka-topics.sh</code>不带任何参数的命令来显示使用信息。例如，它还可以向您显示 新主题的 <a href="https://kafka.apache.org/documentation/#intro_concepts_and_terms">分区计数等详细信息：</a></p>
<pre><code class="language-bash">$ bin/kafka-topics.sh --describe --topic quickstart-events --bootstrap-server localhost:9092
Topic: quickstart-events        TopicId: NPmZHyhbR9y00wMglMH2sg PartitionCount: 1       ReplicationFactor: 1    Configs:
    Topic: quickstart-events Partition: 0    Leader: 0   Replicas: 0 Isr: 0
</code></pre>
<h3 id="4">第 4 步：将一些事件写入主题</h3>
<p>Kafka 客户端通过网络与 Kafka 代理进行通信以写入（或读取）事件。一旦收到，代理将以持久且容错的方式存储事件，只要您需要，甚至永远存储。</p>
<p>运行控制台生产者客户端以将一些事件写入您的主题。默认情况下，您输入的每一行都会导致将一个单独的事件写入主题。</p>
<pre><code class="language-bash">$ bin/kafka-console-producer.sh --topic quickstart-events --bootstrap-server localhost:9092
This is my first event
This is my second event
</code></pre>
<p><code>Ctrl-C</code>您可以随时 停止生产者客户端。</p>
<h3 id="5">第 5 步：阅读事件</h3>
<p>打开另一个终端会话并运行控制台消费者客户端来读取您刚刚创建的事件：</p>
<pre><code class="language-bash">$ bin/kafka-console-consumer.sh --topic quickstart-events --from-beginning --bootstrap-server localhost:9092
This is my first event
This is my second event
</code></pre>
<p><code>Ctrl-C</code>您可以随时停止消费者客户端。</p>
<p>请随意尝试：例如，切换回生产者终端（上一步）以编写其他事件，并查看事件如何立即显示在消费者终端中。</p>
<p>由于事件持久存储在 Kafka 中，因此它们可以被任意数量的消费者读取任意多次。您可以通过打开另一个终端会话并再次重新运行之前的命令来轻松验证这一点。</p>
<h3 id="6-kafka-connect">第 6 步：使用 KAFKA CONNECT 将数据作为事件流导入/导出</h3>
<p>您可能在关系数据库或传统消息传递系统等现有系统中拥有大量数据，以及已经使用这些系统的许多应用程序。 <a href="https://kafka.apache.org/documentation/#connect">Kafka Connect</a>允许您不断地将数据从外部系统摄取到 Kafka 中，反之亦然。<em>它是一个运行连接器</em>的可扩展工具 ，它实现与外部系统交互的自定义​​逻辑。因此，将现有系统与 Kafka 集成非常容易。为了使这个过程更加容易，有数百个这样的连接器可供使用。</p>
<p>在本快速入门中，我们将了解如何使用简单的连接器运行 Kafka Connect，将数据从文件导入到 Kafka 主题，并将数据从 Kafka 主题导出到文件。</p>
<p>首先，确保添加<code>connect-file-3.5.0.jar</code>到<code>plugin.path</code>Connect 工作线程配置中的属性。出于本快速入门的目的，我们将使用相对路径并将连接器的包视为 uber jar，它在从安装目录运行快速入门命令时起作用。但是，值得注意的是，对于生产部署，使用绝对路径始终是更好的选择。有关如何设置此配置的详细说明， 请参阅<a href="https://kafka.apache.org/documentation/#connectconfigs_plugin.path">plugin.path 。</a></p>
<p>编辑<code>config/connect-standalone.properties</code>文件，添加或更改与<code>plugin.path</code>以下内容匹配的配置属性，然后保存文件：</p>
<pre><code class="language-bash">&gt; echo &quot;plugin.path=libs/connect-file-3.5.0.jar&quot;
</code></pre>
<p>然后，首先创建一些种子数据进行测试：</p>
<pre><code class="language-bash">&gt; echo -e &quot;foo\nbar&quot; &gt; test.txt
</code></pre>
<p>或者在 Windows 上：</p>
<pre><code class="language-bash">&gt; echo foo&gt; test.txt
&gt; echo bar&gt;&gt; test.txt
</code></pre>
<p>接下来，我们将启动两个以<em>独立</em>模式运行的连接器，这意味着它们在单个本地专用进程中运行。我们提供三个配置文件作为参数。第一个始终是 Kafka Connect 进程的配置，包含常见配置，例如要连接的 Kafka 代理和数据的序列化格式。其余配置文件各自指定要创建的连接器。这些文件包括唯一的连接器名称、要实例化的连接器类以及连接器所需的任何其他配置。</p>
<pre><code class="language-bash">&gt; bin/connect-standalone.sh config/connect-standalone.properties config/connect-file-source.properties config/connect-file-sink.properties
</code></pre>
<p>这些示例配置文件包含在 Kafka 中，使用您之前启动的默认本地集群配置并创建两个连接器：第一个是源连接器，用于从输入文件读取行并将每行生成到 Kafka 主题，第二个是接收器连接器从 Kafka 主题读取消息并将每条消息生成为输出文件中的一行。</p>
<p>在启动过程中，您将看到许多日志消息，其中包括一些指示连接器正在实例化的日志消息。一旦 Kafka Connect 进程启动，源连接器应开始从<code>test.txt</code>主题读取行并将其生成到主题<code>connect-test</code>，接收器连接器应开始从主题读取消息<code>connect-test</code> 并将其写入文件<code>test.sink.txt</code>。我们可以通过检查输出文件的内容来验证数据是否已通过整个管道传递：</p>
<pre><code class="language-bash">&gt; more test.sink.txt
foo
bar
</code></pre>
<p>请注意，数据存储在 Kafka topic 中<code>connect-test</code>，因此我们还可以运行控制台消费者来查看主题中的数据（或使用自定义消费者代码来处理它）：</p>
<pre><code class="language-bash">&gt; bin/kafka-console-consumer.sh --bootstrap-server localhost:9092 --topic connect-test --from-beginning
{&quot;schema&quot;:{&quot;type&quot;:&quot;string&quot;,&quot;optional&quot;:false},&quot;payload&quot;:&quot;foo&quot;}
{&quot;schema&quot;:{&quot;type&quot;:&quot;string&quot;,&quot;optional&quot;:false},&quot;payload&quot;:&quot;bar&quot;}
...
</code></pre>
<p>连接器继续处理数据，因此我们可以将数据添加到文件并查看它在管道中移动：</p>
<pre><code class="language-bash">&gt; echo Another line&gt;&gt; test.txt
</code></pre>
<p>您应该看到该行出现在控制台使用者输出和接收器文件中。</p>
<h3 id="7-kafka-streams">第 7 步：使用 KAFKA STREAMS 处理您的事件</h3>
<p><a href="https://kafka.apache.org/documentation/streams">将数据作为事件存储在 Kafka 中后，您可以使用适用于 Java/Scala 的Kafka Streams</a>客户端库 处理数据 。它允许您实现关键任务实时应用程序和微服务，其中输入和/或输出数据存储在 Kafka 主题中。Kafka Streams 将客户端编写和部署标准 Java 和 Scala 应用程序的简单性与 Kafka 服务器端集群技术的优点相结合，使这些应用程序具有高度可扩展性、弹性、容错性和分布式性。该库支持一次性处理、有状态操作和聚合、窗口、连接、基于事件时间的处理等等。</p>
<p>为了让您初步体验一下，以下是如何实现流行的<code>WordCount</code>算法：</p>
<pre><code class="language-bash">KStream&lt;String, String&gt; textLines = builder.stream(&quot;quickstart-events&quot;);

KTable&lt;String, Long&gt; wordCounts = textLines
            .flatMapValues(line -&gt; Arrays.asList(line.toLowerCase().split(&quot; &quot;)))
            .groupBy((keyIgnored, word) -&gt; word)
            .count();

wordCounts.toStream().to(&quot;output-topic&quot;, Produced.with(Serdes.String(), Serdes.Long()));
</code></pre>
<p>Kafka <a href="https://kafka.apache.org/documentation/streams/quickstart">Streams 演示</a> 和<a href="https://kafka.apache.org/35/documentation/streams/tutorial">应用程序开发教程</a> 演示了如何从头到尾编码和运行此类流应用程序。</p>
<h3 id="8kafka">步骤8：终止KAFKA环境</h3>
<p>现在您已经完成了快速入门，可以随意拆除 Kafka 环境，或者继续尝试。</p>
<ol>
<li><code>Ctrl-C</code>如果您还没有这样做， 请使用 停止生产者和消费者客户端。</li>
<li>使用 停止 Kafka 代理<code>Ctrl-C</code>。</li>
<li>最后，如果遵循 Kafka with ZooKeeper 部分，请使用 停止 ZooKeeper 服务器<code>Ctrl-C</code>。</li>
</ol>
<p>如果您还想删除本地 Kafka 环境的任何数据，包括您在此过程中创建的任何事件，请运行以下命令：</p>
<pre><code class="language-bash">$ rm -rf /tmp/kafka-logs /tmp/zookeeper /tmp/kraft-combined-logs
</code></pre>
<h3 id="_12">恭喜！</h3>
<p>您已成功完成 Apache Kafka 快速入门。</p>
<p>要了解更多信息，我们建议执行以下后续步骤：</p>
<ul>
<li>阅读简短的<a href="https://kafka.apache.org/intro">简介</a> ，了解 Kafka 在高层次上的工作原理、主要概念以及与其他技术的比较。要更详细地了解 Kafka，请访问 <a href="https://kafka.apache.org/documentation/">文档</a>。</li>
<li>浏览<a href="https://kafka.apache.org/powered-by">用例，</a>了解我们全球社区中的其他用户如何从 Kafka 中获取价值。</li>
<li>加入<a href="https://kafka.apache.org/events">当地的 Kafka 聚会小组</a>， 观看Kafka 社区主要会议 <a href="https://kafka-summit.org/past-events/">Kafka Summit 的演讲。</a></li>
</ul>
<h2 id="14">1.4 生态系统</h2>
<p>在主发行版之外，有大量与 Kafka 集成的工具。生态<a href="https://cwiki.apache.org/confluence/display/KAFKA/Ecosystem">系统页面</a>列出了其中的许多内容，包括流处理系统、Hadoop 集成、监控和部署工具。</p>
<h2 id="15">1.5 旧版本升级</h2>
<h3 id="08x-34x-351">从 0.8.x 到 3.4.x 的任何版本升级到 3.5.1</h3>
<p><a href="https://kafka.apache.org/documentation/#upgrade_3_5_0">所有升级步骤与升级到 3.5.0</a> 相同<a href="https://kafka.apache.org/documentation/#upgrade_3_5_0"></a></p>
<h4 id="351">3.5.1 中的显着变化</h4>
<ul>
<li>将依赖项 snappy-java 升级到不易受 <a href="https://nvd.nist.gov/vuln/detail/CVE-2023-34455">CVE-2023-34455 影响的版本。</a> 您可以在 Kafka CVE 列表中找到有关 CVE 的更多信息<a href="https://kafka.apache.org/cve-list#CVE-2023-34455">。</a></li>
<li>修复了 3.3.0 中引入的回归，该回归导致<code>security.protocol</code>配置值仅限于大写。修复后，<code>security.protocol</code>值不区分大小写。有关详细信息，请参阅<a href="https://issues.apache.org/jira/browse/KAFKA-15053">KAFKA-15053</a>。</li>
</ul>
<h3 id="08x-34x-350">从 0.8.x 到 3.4.x 的任何版本升级到 3.5.0</h3>
<h4 id="350">3.5.0 中的显着变化</h4>
<ul>
<li>Kafka Streams 引入了一种新的状态存储类型，即版本化键值存储，用于每个键存储多个记录版本，从而使带时间戳的检索操作能够返回指定时间戳的最新记录（每个键）。 有关更多详细信息，请参阅<a href="https://cwiki.apache.org/confluence/display/KAFKA/KIP-889%3A+Versioned+State+Stores">KIP-889</a> 和<a href="https://cwiki.apache.org/confluence/display/KAFKA/KIP-914%3A+DSL+Processor+Semantics+for+Versioned+Stores">KIP-914 。</a>如果在 DSL 中使用新的存储类型，则将应用改进的处理语义，如 <a href="https://cwiki.apache.org/confluence/display/KAFKA/KIP-914%3A+DSL+Processor+Semantics+for+Versioned+Stores">KIP-914</a>中所述。</li>
<li><a href="https://cwiki.apache.org/confluence/display/KAFKA/KIP-904%3A+Kafka+Streams+-+Guarantee+subtractor+is+called+before+adder+if+key+has+not+changed">KTable 聚合语义通过KIP-904</a>得到了进一步改进 ，现在避免了虚假的中间结果。</li>
<li>Kafka Streams<code>ProductionExceptionHandler</code>通过 <a href="https://cwiki.apache.org/confluence/display/KAFKA/KIP-399%3A+Extend+ProductionExceptionHandler+to+cover+serialization+exceptions">KIP-399</a>进行了改进，现在还涵盖了序列化错误。</li>
<li>MirrorMaker 现在默认使用增量AlterConfigs API 来同步主题配置，而不是已弃用的 alterConfigs API。引入了一个名为 的新设置，<code>use.incremental.alter.configs</code>允许用户控制要使用的 API。当始终使用增量AlterConfigs API 时，此新设置已标记为已弃用，并将在下一个主要版本中删除。有关更多详细信息， 请参阅<a href="https://cwiki.apache.org/confluence/display/KAFKA/KIP-894%3A+Use+incrementalAlterConfigs+API+for+syncing+topic+configurations">KIP-894 。</a></li>
<li>JmxTool、EndToEndLatency、StreamsResetter、ConsumerPerformance 和 ClusterTool 已迁移到工具模块。“kafka.tools”包已弃用，并将在下一个主要版本中更改为“org.apache.kafka.tools”。有关更多详细信息， 请参阅<a href="https://issues.apache.org/jira/browse/KAFKA-14525">KAFKA-14525 。</a></li>
</ul>
<h4 id="zookeeper">升级基于ZooKeeper的集群</h4>
<p><strong>如果您要从 2.1.x 之前的版本升级，请参阅下面步骤 5 中有关用于存储消费者偏移量的架构更改的注释。一旦您将 inter.broker.protocol.version 更改为最新版本，将无法降级到 2.1 之前的版本。</strong></p>
<p><strong>对于滚动升级：</strong></p>
<ol>
<li>
<p>更新所有代理上的 server.properties 并添加以下属性。CURRENT_KAFKA_VERSION 是指您要升级的版本。CURRENT_MESSAGE_FORMAT_VERSION 指当前使用的消息格式版本。如果您之前已覆盖消息格式版本，则应保留其当前值。或者，如果您要从 0.11.0.x 之前的版本升级，则应将 CURRENT_MESSAGE_FORMAT_VERSION 设置为与 CURRENT_KAFKA_VERSION 匹配。</p>
<ul>
<li>inter.broker.protocol.version=CURRENT_KAFKA_VERSION （例如<code>3.4</code>、<code>3.3</code>等）</li>
<li>log.message.format.version=CURRENT_MESSAGE_FORMAT_VERSION（有关此配置的详细信息，请参阅<a href="https://kafka.apache.org/documentation/#upgrade_10_performance_impact">升级后的潜在性能影响。）</a></li>
</ul>
<p>如果您从0.11.0.x或更高版本升级，并且没有覆盖消息格式，那么您只需要覆盖代理间协议版本。
*   inter.broker.protocol.version=CURRENT_KAFKA_VERSION （例如<code>3.4</code>、<code>3.3</code>等）
2.  一次升级一个代理：关闭代理，更新代码，然后重新启动。完成此操作后，代理将运行最新版本，您可以验证集群的行为和性能是否符合预期。如果出现任何问题，此时仍然可以降级。
3.  验证集群的行为和性能后，通过编辑协议版本 <code>inter.broker.protocol.version</code>并将其设置为 来提升协议版本<code>3.5</code>。
4.  一一重启broker，新协议版本即可生效。一旦代理开始使用最新的协议版本，就无法再将集群降级到旧版本。
5.  如果您已按照上述说明覆盖消息格式版本，则需要再进行一次滚动重启才能将其升级到最新版本。一旦所有（或大多数）消费者升级到 0.11.0 或更高版本，将每个代理上的 log.message.format.version 更改为 3.5 并一一重新启动它们。请注意，不再维护的旧版 Scala 客户端不支持 0.11 中引入的消息格式，因此为了避免转换成本（或利用<a href="https://kafka.apache.org/documentation/#upgrade_11_exactly_once_semantics">恰好一次语义</a>），必须使用较新的 Java 客户端。</p>
</li>
</ol>
<h4 id="kraft">升级基于KRaft的集群</h4>
<p><strong>如果您是从 3.3.0 之前的版本升级，请参阅下面步骤 3 中的注释。将metadata.version更改为最新版本后，将无法降级到3.3-IV0之前的版本。</strong></p>
<p><strong>对于滚动升级：</strong></p>
<ol>
<li>一次升级一个代理：关闭代理，更新代码，然后重新启动。完成此操作后，代理将运行最新版本，您可以验证集群的行为和性能是否符合预期。</li>
<li>一旦集群的行为和性能得到验证，通过运行来提升metadata.version <code>./bin/kafka-features.sh upgrade --metadata 3.5</code></li>
<li>请注意，集群元数据版本升级后无法降级到预生产 3.0.x、3.1.x 或 3.2.x 版本。但是，可以降级到生产版本，例如 3.3-IV0、3.3-IV1 等。</li>
</ol>
<h3 id="08x-33x-340">从 0.8.x 到 3.3.x 的任何版本升级到 3.4.0</h3>
<p><strong>如果您要从 2.1.x 之前的版本升级，请参阅下面有关用于存储消费者偏移量的架构更改的注释。一旦您将 inter.broker.protocol.version 更改为最新版本，将无法降级到 2.1 之前的版本。</strong></p>
<p><strong>对于滚动升级：</strong></p>
<ol>
<li>
<p>更新所有代理上的 server.properties 并添加以下属性。CURRENT_KAFKA_VERSION 是指您要升级的版本。CURRENT_MESSAGE_FORMAT_VERSION 指当前使用的消息格式版本。如果您之前已覆盖消息格式版本，则应保留其当前值。或者，如果您要从 0.11.0.x 之前的版本升级，则应将 CURRENT_MESSAGE_FORMAT_VERSION 设置为与 CURRENT_KAFKA_VERSION 匹配。</p>
<ul>
<li>inter.broker.protocol.version=CURRENT_KAFKA_VERSION （例如<code>3.3</code>、<code>3.2</code>等）</li>
<li>log.message.format.version=CURRENT_MESSAGE_FORMAT_VERSION（有关此配置的详细信息，请参阅<a href="https://kafka.apache.org/documentation/#upgrade_10_performance_impact">升级后的潜在性能影响。）</a></li>
</ul>
<p>如果您从0.11.0.x或更高版本升级，并且没有覆盖消息格式，那么您只需要覆盖代理间协议版本。
*   inter.broker.protocol.version=CURRENT_KAFKA_VERSION （例如<code>3.3</code>、<code>3.2</code>等）
2.  一次升级一个代理：关闭代理，更新代码，然后重新启动。完成此操作后，代理将运行最新版本，您可以验证集群的行为和性能是否符合预期。如果出现任何问题，此时仍然可以降级。
3.  验证集群的行为和性能后，通过编辑协议版本 <code>inter.broker.protocol.version</code>并将其设置为 来提升协议版本<code>3.4</code>。
4.  一一重启broker，新协议版本即可生效。一旦代理开始使用最新的协议版本，就无法再将集群降级到旧版本。
5.  如果您已按照上述说明覆盖消息格式版本，则需要再进行一次滚动重启才能将其升级到最新版本。一旦所有（或大多数）消费者升级到 0.11.0 或更高版本，将每个代理上的 log.message.format.version 更改为 3.4 并一一重新启动它们。请注意，不再维护的旧版 Scala 客户端不支持 0.11 中引入的消息格式，因此为了避免转换成本（或利用<a href="https://kafka.apache.org/documentation/#upgrade_11_exactly_once_semantics">恰好一次语义</a>），必须使用较新的 Java 客户端。</p>
</li>
</ol>
<h3 id="kraft-30x-33x-340">将基于 KRaft 的集群从 3.0.x 到 3.3.x 的任何版本升级到 3.4.0</h3>
<p><strong>如果您是从 3.3.0 之前的版本升级，请参阅下面的注释。将metadata.version更改为最新版本后，将无法降级到3.3-IV0之前的版本。</strong></p>
<p><strong>对于滚动升级：</strong></p>
<ol>
<li>一次升级一个代理：关闭代理，更新代码，然后重新启动。完成此操作后，代理将运行最新版本，您可以验证集群的行为和性能是否符合预期。</li>
<li>一旦集群的行为和性能得到验证，通过运行来提升metadata.version <code>./bin/kafka-features.sh upgrade --metadata 3.4</code></li>
<li>请注意，集群元数据版本升级后无法降级到预生产 3.0.x、3.1.x 或 3.2.x 版本。但是，可以降级到生产版本，例如 3.3-IV0、3.3-IV1 等。</li>
</ol>
<h4 id="340">3.4.0 中的显着变化</h4>
<ul>
<li>自 Apache Kafka 3.4.0 起，我们添加了一个系统属性（“org.apache.kafka.disallowed.login.modules”）来禁用 SASL JAAS 配置中有问题的登录模块使用。默认情况下，“com.sun.security.auth.module.JndiLoginModule”在 Apache Kafka 3.4.0 中被禁用。</li>
</ul>
<h3 id="08x-32x-331">从 0.8.x 到 3.2.x 的任何版本升级到 3.3.1</h3>
<p><strong>如果您要从 2.1.x 之前的版本升级，请参阅下面有关用于存储消费者偏移量的架构更改的注释。一旦您将 inter.broker.protocol.version 更改为最新版本，将无法降级到 2.1 之前的版本。</strong></p>
<p><strong>对于滚动升级：</strong></p>
<ol>
<li>
<p>更新所有代理上的 server.properties 并添加以下属性。CURRENT_KAFKA_VERSION 是指您要升级的版本。CURRENT_MESSAGE_FORMAT_VERSION 指当前使用的消息格式版本。如果您之前已覆盖消息格式版本，则应保留其当前值。或者，如果您要从 0.11.0.x 之前的版本升级，则应将 CURRENT_MESSAGE_FORMAT_VERSION 设置为与 CURRENT_KAFKA_VERSION 匹配。</p>
<ul>
<li>inter.broker.protocol.version=CURRENT_KAFKA_VERSION （例如<code>3.2</code>、<code>3.1</code>等）</li>
<li>log.message.format.version=CURRENT_MESSAGE_FORMAT_VERSION（有关此配置的详细信息，请参阅<a href="https://kafka.apache.org/documentation/#upgrade_10_performance_impact">升级后的潜在性能影响。）</a></li>
</ul>
<p>如果您从0.11.0.x或更高版本升级，并且没有覆盖消息格式，那么您只需要覆盖代理间协议版本。
*   inter.broker.protocol.version=CURRENT_KAFKA_VERSION （例如<code>3.2</code>、<code>3.1</code>等）
2.  一次升级一个代理：关闭代理，更新代码，然后重新启动。完成此操作后，代理将运行最新版本，您可以验证集群的行为和性能是否符合预期。如果出现任何问题，此时仍然可以降级。
3.  验证集群的行为和性能后，通过编辑协议版本 <code>inter.broker.protocol.version</code>并将其设置为 来提升协议版本<code>3.3</code>。
4.  一一重启broker，新协议版本即可生效。一旦代理开始使用最新的协议版本，就无法再将集群降级到旧版本。
5.  如果您已按照上述说明覆盖消息格式版本，则需要再进行一次滚动重启才能将其升级到最新版本。一旦所有（或大多数）消费者升级到 0.11.0 或更高版本，将每个代理上的 log.message.format.version 更改为 3.3 并一一重新启动它们。请注意，不再维护的旧版 Scala 客户端不支持 0.11 中引入的消息格式，因此为了避免转换成本（或利用<a href="https://kafka.apache.org/documentation/#upgrade_11_exactly_once_semantics">恰好一次语义</a>），必须使用较新的 Java 客户端。</p>
</li>
</ol>
<h3 id="kraft-30x-32x-331">将基于 KRaft 的集群从 3.0.x 到 3.2.x 的任何版本升级到 3.3.1</h3>
<p><strong>如果您要从 3.3.1 之前的版本升级，请参阅下面的注释。将metadata.version更改为最新版本后，将无法降级到3.3-IV0之前的版本。</strong></p>
<p><strong>对于滚动升级：</strong></p>
<ol>
<li>一次升级一个代理：关闭代理，更新代码，然后重新启动。完成此操作后，代理将运行最新版本，您可以验证集群的行为和性能是否符合预期。</li>
<li>一旦集群的行为和性能得到验证，通过运行来提升metadata.version <code>./bin/kafka-features.sh upgrade --metadata 3.3</code></li>
<li>请注意，集群元数据版本升级后无法降级到预生产 3.0.x、3.1.x 或 3.2.x 版本。但是，可以降级到生产版本，例如 3.3-IV0、3.3-IV1 等。</li>
</ol>
<h4 id="331">3.3.1 中的显着变化</h4>
<ul>
<li>KRaft 模式已为新集群做好生产准备。 有关更多详细信息（包括限制）， 请参阅<a href="https://cwiki.apache.org/confluence/display/KAFKA/KIP-833%3A+Mark+KRaft+as+Production+Ready">KIP-833 。</a></li>
<li>默认情况下用于没有键的记录的分区器已得到改进，以避免当一个或多个代理速度缓慢时出现病态行为。新逻辑可能会影响批处理行为，可以使用<code>batch.size</code>和/或<code>linger.ms</code>配置设置来调整批处理行为。可以通过设置恢复以前的行为<code>partitioner.class=org.apache.kafka.clients.producer.internals.DefaultPartitioner</code>。有关更多详细信息， 请参阅<a href="https://cwiki.apache.org/confluence/display/KAFKA/KIP-794%3A+Strictly+Uniform+Sticky+Partitioner">KIP-794 。</a></li>
<li>如上所述，现在 KRaft 集群的升级过程与基于 ZK 的集群略有不同。</li>
<li>引入了一个新的 API，如果不存在，<code>addMetricIfAbsent</code>它将<code>Metrics</code>创建一个新的指标；如果已经注册，则返回相同的指标。请注意，此行为与 API 不同，后者在尝试创建已存在的指标时<code>addMetric</code>抛出。<code>IllegalArgumentException</code>（ 有关更多详细信息， 请参阅<a href="https://cwiki.apache.org/confluence/display/KAFKA/KIP-843%3A+Adding+addMetricIfAbsent+method+to+Metrics">KIP-843 ）。</a></li>
</ul>
<h3 id="08x-31x-320">从 0.8.x 到 3.1.x 的任何版本升级到 3.2.0</h3>
<p><strong>如果您要从 2.1.x 之前的版本升级，请参阅下面有关用于存储消费者偏移量的架构更改的注释。一旦您将 inter.broker.protocol.version 更改为最新版本，将无法降级到 2.1 之前的版本。</strong></p>
<p><strong>对于滚动升级：</strong></p>
<ol>
<li>
<p>更新所有代理上的 server.properties 并添加以下属性。CURRENT_KAFKA_VERSION 是指您要升级的版本。CURRENT_MESSAGE_FORMAT_VERSION 指当前使用的消息格式版本。如果您之前已覆盖消息格式版本，则应保留其当前值。或者，如果您要从 0.11.0.x 之前的版本升级，则应将 CURRENT_MESSAGE_FORMAT_VERSION 设置为与 CURRENT_KAFKA_VERSION 匹配。</p>
<ul>
<li>inter.broker.protocol.version=CURRENT_KAFKA_VERSION （例如<code>3.1</code>、<code>3.0</code>等）</li>
<li>log.message.format.version=CURRENT_MESSAGE_FORMAT_VERSION（有关此配置的详细信息，请参阅<a href="https://kafka.apache.org/documentation/#upgrade_10_performance_impact">升级后的潜在性能影响。）</a></li>
</ul>
<p>如果您从0.11.0.x或更高版本升级，并且没有覆盖消息格式，那么您只需要覆盖代理间协议版本。
*   inter.broker.protocol.version=CURRENT_KAFKA_VERSION （例如<code>3.1</code>、<code>3.0</code>等）
2.  一次升级一个代理：关闭代理，更新代码，然后重新启动。完成此操作后，代理将运行最新版本，您可以验证集群的行为和性能是否符合预期。如果出现任何问题，此时仍然可以降级。
3.  验证集群的行为和性能后，通过编辑协议版本 <code>inter.broker.protocol.version</code>并将其设置为 来提升协议版本<code>3.2</code>。
4.  一一重启broker，新协议版本即可生效。一旦代理开始使用最新的协议版本，就无法再将集群降级到旧版本。
5.  如果您已按照上述说明覆盖消息格式版本，则需要再进行一次滚动重启才能将其升级到最新版本。一旦所有（或大多数）消费者升级到 0.11.0 或更高版本，将每个代理上的 log.message.format.version 更改为 3.2 并一一重新启动它们。请注意，不再维护的旧版 Scala 客户端不支持 0.11 中引入的消息格式，因此为了避免转换成本（或利用<a href="https://kafka.apache.org/documentation/#upgrade_11_exactly_once_semantics">恰好一次语义</a>），必须使用较新的 Java 客户端。</p>
</li>
</ol>
<h4 id="320">3.2.0 中的显着变化</h4>
<ul>
<li>如果没有设置冲突的配置，默认情况下会启用生产者的幂等性。当向 2.8.0 之前的经纪商生产时，<code>IDEMPOTENT_WRITE</code>需要许可。<a href="https://cwiki.apache.org/confluence/display/KAFKA/KIP-679%3A+Producer+will+enable+the+strongest+delivery+guarantee+by+default#KIP679:Producerwillenablethestrongestdeliveryguaranteebydefault-Compatibility,Deprecation,andMigrationPlan">有关详细信息，请检查KIP-679</a>的兼容性部分 。在 3.0.0 和 3.1.0 中，一个错误阻止了应用此默认值，这意味着除非用户明确设置<code>enable.idempotence</code>为 true，否则幂等性仍然处于禁用状态（有关更多详细信息，请参阅<a href="https://issues.apache.org/jira/browse/KAFKA-13598">KAFKA-13598</a>）。此问题已修复，默认值已在 3.0.1、3.1.1 和 3.2.0 中正确应用。</li>
<li>一个值得注意的例外是 Connect，它默认禁用所有生产者的幂等行为，以便统一支持使用各种 Kafka 代理版本。用户可以更改此行为，以通过 Connect Worker 和/或连接器配置为部分或所有生产者启用幂等性。Connect 可能会在未来的主要版本中默认启用幂等生产者。</li>
<li>出于安全考虑，Kafka 用 reload4j 取代了 log4j。这仅影响指定日志记录后端的模块（<code>connect-runtime</code>和<code>kafka-tools</code>是两个这样的示例）。许多模块（包括 ）<code>kafka-clients</code>将其留给应用程序来指定日志记录后端。<a href="https://reload4j.qos.ch/">更多信息可以在reload4j</a>找到。依赖于 Kafka 项目中受影响模块的项目应使用 <a href="https://www.slf4j.org/manual.html#swapping">slf4j-log4j12 版本 1.7.35 或更高版本</a>或 slf4j-reload4j 以避免 <a href="https://www.slf4j.org/codes.html#no_tlm">源自日志记录框架的可能的兼容性问题</a>。</li>
<li>示例连接器<code>FileStreamSourceConnector</code>和<code>FileStreamSinkConnector</code>已从默认类路径中删除。要在 Kafka Connect 独立或分布式模式下使用它们，需要显式添加它们，例如<code>CLASSPATH=./lib/connect-file-3.2.0.jar ./bin/connect-distributed.sh</code>.</li>
</ul>
<h3 id="08x-30x-310">从 0.8.x 到 3.0.x 的任何版本升级到 3.1.0</h3>
<p><strong>如果您要从 2.1.x 之前的版本升级，请参阅下面有关用于存储消费者偏移量的架构更改的注释。一旦您将 inter.broker.protocol.version 更改为最新版本，将无法降级到 2.1 之前的版本。</strong></p>
<p><strong>对于滚动升级：</strong></p>
<ol>
<li>
<p>更新所有代理上的 server.properties 并添加以下属性。CURRENT_KAFKA_VERSION 是指您要升级的版本。CURRENT_MESSAGE_FORMAT_VERSION 指当前使用的消息格式版本。如果您之前已覆盖消息格式版本，则应保留其当前值。或者，如果您要从 0.11.0.x 之前的版本升级，则应将 CURRENT_MESSAGE_FORMAT_VERSION 设置为与 CURRENT_KAFKA_VERSION 匹配。</p>
<ul>
<li>inter.broker.protocol.version=CURRENT_KAFKA_VERSION （例如<code>3.0</code>、<code>2.8</code>等）</li>
<li>log.message.format.version=CURRENT_MESSAGE_FORMAT_VERSION（有关此配置的详细信息，请参阅<a href="https://kafka.apache.org/documentation/#upgrade_10_performance_impact">升级后的潜在性能影响。）</a></li>
</ul>
<p>如果您从0.11.0.x或更高版本升级，并且没有覆盖消息格式，那么您只需要覆盖代理间协议版本。
*   inter.broker.protocol.version=CURRENT_KAFKA_VERSION （例如<code>3.0</code>、<code>2.8</code>等）
2.  一次升级一个代理：关闭代理，更新代码，然后重新启动。完成此操作后，代理将运行最新版本，您可以验证集群的行为和性能是否符合预期。如果出现任何问题，此时仍然可以降级。
3.  验证集群的行为和性能后，通过编辑协议版本 <code>inter.broker.protocol.version</code>并将其设置为 来提升协议版本<code>3.1</code>。
4.  一一重启broker，新协议版本即可生效。一旦代理开始使用最新的协议版本，就无法再将集群降级到旧版本。
5.  如果您已按照上述说明覆盖消息格式版本，则需要再进行一次滚动重启才能将其升级到最新版本。一旦所有（或大多数）消费者升级到 0.11.0 或更高版本，将每个代理上的 log.message.format.version 更改为 3.1 并一一重新启动它们。请注意，不再维护的旧版 Scala 客户端不支持 0.11 中引入的消息格式，因此为了避免转换成本（或利用<a href="https://kafka.apache.org/documentation/#upgrade_11_exactly_once_semantics">恰好一次语义</a>），必须使用较新的 Java 客户端。</p>
</li>
</ol>
<h4 id="311">3.1.1 中的显着变化</h4>
<ul>
<li>如果没有设置冲突的配置，默认情况下会启用生产者的幂等性。当向 2.8.0 之前的经纪商生产时，<code>IDEMPOTENT_WRITE</code>需要许可。<a href="https://cwiki.apache.org/confluence/display/KAFKA/KIP-679%3A+Producer+will+enable+the+strongest+delivery+guarantee+by+default#KIP679:Producerwillenablethestrongestdeliveryguaranteebydefault-Compatibility,Deprecation,andMigrationPlan">有关详细信息，请检查KIP-679</a>的兼容性部分 。一个错误阻止了生产者幂等性默认值的应用，这意味着除非用户明确设置<code>enable.idempotence</code>为 true，否则它仍然处于禁用状态。有关更多详细信息，请参阅<a href="https://issues.apache.org/jira/browse/KAFKA-13598">KAFKA-13598 。</a>此问题已修复并且默认值已正确应用。</li>
<li>一个值得注意的例外是 Connect，它默认禁用所有生产者的幂等行为，以便统一支持使用各种 Kafka 代理版本。用户可以更改此行为，以通过 Connect Worker 和/或连接器配置为部分或所有生产者启用幂等性。Connect 可能会在未来的主要版本中默认启用幂等生产者。</li>
<li>出于安全考虑，Kafka 用 reload4j 取代了 log4j。这仅影响指定日志记录后端的模块（<code>connect-runtime</code>和<code>kafka-tools</code>是两个这样的示例）。许多模块（包括 ）<code>kafka-clients</code>将其留给应用程序来指定日志记录后端。<a href="https://reload4j.qos.ch/">更多信息可以在reload4j</a>找到。依赖于 Kafka 项目中受影响模块的项目应使用 <a href="https://www.slf4j.org/manual.html#swapping">slf4j-log4j12 版本 1.7.35 或更高版本</a>或 slf4j-reload4j 以避免 <a href="https://www.slf4j.org/codes.html#no_tlm">源自日志记录框架的可能的兼容性问题</a>。</li>
</ul>
<h4 id="310">3.1.0 中的显着变化</h4>
<ul>
<li>Apache Kafka 支持 Java 17。</li>
<li>以下指标已被弃用：<code>bufferpool-wait-time-total</code>、<code>io-waittime-total</code>和<code>iotime-total</code>。请使用<code>bufferpool-wait-time-ns-total</code>、<code>io-wait-time-ns-total</code>、 和<code>io-time-ns-total</code>代替。 有关更多详细信息，请参阅<a href="https://cwiki.apache.org/confluence/display/KAFKA/KIP-773%3A+Differentiate+consistently+metric+latency+measured+in+millis+and+nanos">KIP-773 。</a></li>
<li><a href="https://cwiki.apache.org/confluence/display/KAFKA/KIP-516%3A+Topic+Identifiers">IBP 3.1 将主题 ID 作为KIP-516</a>的一部分引入 FetchRequest 。</li>
</ul>
<h3 id="08x-28x-301">从 0.8.x 到 2.8.x 的任何版本升级到 3.0.1</h3>
<p><strong>如果您要从 2.1.x 之前的版本升级，请参阅下面有关用于存储消费者偏移量的架构更改的注释。一旦您将 inter.broker.protocol.version 更改为最新版本，将无法降级到 2.1 之前的版本。</strong></p>
<p><strong>对于滚动升级：</strong></p>
<ol>
<li>
<p>更新所有代理上的 server.properties 并添加以下属性。CURRENT_KAFKA_VERSION 是指您要升级的版本。CURRENT_MESSAGE_FORMAT_VERSION 指当前使用的消息格式版本。如果您之前已覆盖消息格式版本，则应保留其当前值。或者，如果您要从 0.11.0.x 之前的版本升级，则应将 CURRENT_MESSAGE_FORMAT_VERSION 设置为与 CURRENT_KAFKA_VERSION 匹配。</p>
<ul>
<li>inter.broker.protocol.version=CURRENT_KAFKA_VERSION （例如<code>2.8</code>、<code>2.7</code>等）</li>
<li>log.message.format.version=CURRENT_MESSAGE_FORMAT_VERSION（有关此配置的详细信息，请参阅<a href="https://kafka.apache.org/documentation/#upgrade_10_performance_impact">升级后的潜在性能影响。）</a></li>
</ul>
<p>如果您从0.11.0.x或更高版本升级，并且没有覆盖消息格式，那么您只需要覆盖代理间协议版本。
*   inter.broker.protocol.version=CURRENT_KAFKA_VERSION （例如<code>2.8</code>、<code>2.7</code>等）
2.  一次升级一个代理：关闭代理，更新代码，然后重新启动。完成此操作后，代理将运行最新版本，您可以验证集群的行为和性能是否符合预期。如果出现任何问题，此时仍然可以降级。
3.  验证集群的行为和性能后，通过编辑协议版本 <code>inter.broker.protocol.version</code>并将其设置为 来提升协议版本<code>3.0</code>。
4.  一一重启broker，新协议版本即可生效。一旦代理开始使用最新的协议版本，就无法再将集群降级到旧版本。
5.  如果您已按照上述说明覆盖消息格式版本，则需要再进行一次滚动重启才能将其升级到最新版本。一旦所有（或大多数）消费者升级到 0.11.0 或更高版本，将每个代理上的 log.message.format.version 更改为 3.0 并一一重新启动它们。请注意，不再维护的旧版 Scala 客户端不支持 0.11 中引入的消息格式，因此为了避免转换成本（或利用<a href="https://kafka.apache.org/documentation/#upgrade_11_exactly_once_semantics">恰好一次语义</a>），必须使用较新的 Java 客户端。</p>
</li>
</ol>
<h4 id="301">3.0.1 中的显着变化</h4>
<ul>
<li>如果没有设置冲突的配置，默认情况下会启用生产者的幂等性。当向 2.8.0 之前的经纪商生产时，<code>IDEMPOTENT_WRITE</code>需要许可。<a href="https://cwiki.apache.org/confluence/display/KAFKA/KIP-679%3A+Producer+will+enable+the+strongest+delivery+guarantee+by+default#KIP679:Producerwillenablethestrongestdeliveryguaranteebydefault-Compatibility,Deprecation,andMigrationPlan">有关详细信息，请检查KIP-679</a>的兼容性部分 。一个错误阻止了生产者幂等性默认值的应用，这意味着除非用户明确设置<code>enable.idempotence</code>为 true，否则它仍然处于禁用状态。有关更多详细信息，请参阅<a href="https://issues.apache.org/jira/browse/KAFKA-13598">KAFKA-13598 。</a>此问题已修复并且默认值已正确应用。</li>
</ul>
<h4 id="300">3.0.0 中的显着变化</h4>
<ul>
<li>默认情况下，生产者具有更强的交付保证：<code>idempotence</code>已启用并<code>acks</code>设置<code>all</code>为而不是<code>1</code>。有关详细信息，请参阅<a href="https://cwiki.apache.org/confluence/display/KAFKA/KIP-679%3A+Producer+will+enable+the+strongest+delivery+guarantee+by+default">KIP-679</a>。在 3.0.0 和 3.1.0 中，一个错误阻止应用幂等默认值，这意味着除非用户明确设置 <code>enable.idempotence</code>为 true，否则它仍然处于禁用状态。请注意，该错误并不影响<code>acks=all</code>更改。有关更多详细信息，请参阅<a href="https://issues.apache.org/jira/browse/KAFKA-13598">KAFKA-13598 。</a>此问题已修复，默认值已在 3.0.1、3.1.1 和 3.2.0 中正确应用。</li>
<li>自 Apache Kafka 3.0 起，Java 8 和 Scala 2.12 支持已被弃用，并将在 Apache Kafka 4.0 中删除。有关更多详细信息，请参阅<a href="https://cwiki.apache.org/confluence/pages/viewpage.action?pageId=181308223">KIP-750</a> 和<a href="https://cwiki.apache.org/confluence/pages/viewpage.action?pageId=181308218">KIP-751 。</a></li>
<li>ZooKeeper已升级至3.6.3版本。</li>
<li>KRaft 模式的预览版可用，但无法从 2.8 早期访问版本升级到该模式。<code>config/kraft/README.md</code>详细信息请参阅文件。</li>
<li>发布 tarball 不再包含测试、源、javadoc 和测试源 jar。这些仍然发布到 Maven 中央存储库。</li>
<li><a href="https://github.com/apache/kafka/pull/10203">现在，运行时类路径（而不是编译和运行时类路径）中提供了</a>许多实现依赖项 jar 。升级后的编译错误可以通过显式添加缺少的依赖项 jar 或更新应用程序以不使用内部类来修复。</li>
<li>消费者配置的默认值<code>session.timeout.ms</code>从 10 秒增加到 45 秒。有关更多详细信息，请参阅 <a href="https://cwiki.apache.org/confluence/display/KAFKA/KIP-735%3A+Increase+default+consumer+session+timeout">KIP-735 。</a></li>
<li>代理配置<code>log.message.format.version</code>和主题配置<code>message.format.version</code>已被弃用。两种配置的值始终假定为<code>3.0</code>if或<code>inter.broker.protocol.version</code>更高<code>3.0</code>。如果设置了<code>log.message.format.version</code>或<code>message.format.version</code>，我们建议在升级到 3.0 的同时清除它们 <code>inter.broker.protocol.version</code>。这将避免降级时潜在的兼容性问题<code>inter.broker.protocol.version</code> 。有关更多详细信息，请参阅<a href="https://cwiki.apache.org/confluence/display/KAFKA/KIP-724%3A+Drop+support+for+message+formats+v0+and+v1">KIP-724 。</a></li>
<li>Streams API 删除了在 2.5.0 或更早版本中已弃用的所有已弃用的 API。有关已删除 API 的完整列表，请比较详细的 Kafka Streams 升级说明。</li>
<li>Kafka Streams 不再对“connect:json”模块有编译时依赖性 ( <a href="https://issues.apache.org/jira/browse/KAFKA-5146">KAFKA-5146</a> )。依赖这种传递依赖的项目必须显式声明它。</li>
<li>通过指定的自定义主体构建器实现<code>principal.builder.class</code>现在必须实现该 <code>KafkaPrincipalSerde</code>接口以允许在代理之间转发。有关 KafkaPrincipalSerde 使用的更多详细信息，请参阅<a href="https://cwiki.apache.org/confluence/display/KAFKA/KIP-590%3A+Redirect+Zookeeper+Mutation+Protocols+to+The+Controller">KIP-590 。</a></li>
<li>
<p>许多已弃用的类、方法和工具已从、 和<code>clients</code>模块<code>connect</code>中删除：<code>core``tools</code></p>
</li>
<li>
<p>Scala<code>Authorizer</code>和<code>SimpleAclAuthorizer</code>相关类已被删除。请使用Java<code>Authorizer</code> 和<code>AclAuthorizer</code>代替。</p>
</li>
<li>该<code>Metric#value()</code>方法已被删除（<a href="https://issues.apache.org/jira/browse/KAFKA-12573">KAFKA-12573</a>）。</li>
<li>和<code>Sum</code>类<code>Total</code>已被删除（<a href="https://issues.apache.org/jira/browse/KAFKA-12584">KAFKA-12584</a>）。请使用<code>WindowedSum</code>and<code>CumulativeSum</code>代替。</li>
<li>和<code>Count</code>类<code>SampledTotal</code>被删除。请分别使用<code>WindowedCount</code>和<code>WindowedSum</code> 来代替。</li>
<li>、<code>PrincipalBuilder</code>和<code>DefaultPrincipalBuilder</code>类<code>ResourceFilter</code>已被删除。</li>
<li><code>SslConfigs</code>、<code>SaslConfigs</code>和<code>AclBinding</code>中 删除了各种常量和构造函数<code>AclBindingFilter</code>。</li>
<li>这些<code>Admin.electedPreferredLeaders()</code>方法已被删除。请改用<code>Admin.electLeaders</code>。</li>
<li>命令行工具<code>kafka-preferred-replica-election</code>已被删除。请改用<code>kafka-leader-election</code>。</li>
<li>该<code>--zookeeper</code>选项已从<code>kafka-topics</code>和<code>kafka-reassign-partitions</code>命令行工具中删除。请改用<code>--bootstrap-server</code>。</li>
<li>在<code>kafka-configs</code>命令行工具中，该<code>--zookeeper</code>选项仅支持更新<a href="https://kafka.apache.org/documentation/#security_sasl_scram_credentials">SCRAM 凭证配置</a> 以及<a href="https://kafka.apache.org/documentation/#dynamicbrokerconfigs">在代理未运行时描述/更新动态代理配置</a>。请用于<code>--bootstrap-server</code> 其他配置操作。</li>
<li>构造函数<code>ConfigEntry</code>被删除（<a href="https://issues.apache.org/jira/browse/KAFKA-12577">KAFKA-12577</a>）。请改用剩余的公共构造函数。</li>
<li><code>default</code>客户端配置的配置值<code>client.dns.lookup</code>已被删除。万一您显式设置此配置，我们建议您保留该配置未设置（<code>use_all_dns_ips</code>默认情况下使用）。</li>
<li>和<code>ExtendedDeserializer</code>类<code>ExtendedSerializer</code>已被删除。请使用<code>Deserializer</code> and<code>Serializer</code>代替。</li>
<li>该<code>close(long, TimeUnit)</code>方法已从生产者、消费者和管理客户端中删除。请使用 <code>close(Duration)</code>.</li>
<li>和<code>ConsumerConfig.addDeserializerToConfig</code>方法<code>ProducerConfig.addSerializerToConfig</code>已被删除。这些方法无意成为公共 API，并且没有替代方法。</li>
<li>该<code>NoOffsetForPartitionException.partition()</code>方法已被删除。请改用<code>partitions()</code> 。</li>
<li>默认值<code>partition.assignment.strategy</code>更改为“[RangeAssignor, CooperativeStickyAssignor]”，默认情况下将使用 RangeAssignor，但允许升级到 CooperativeStickyAssignor，只需一次滚动弹跳即可从列表中删除 RangeAssignor。<a href="https://cwiki.apache.org/confluence/display/KAFKA/KIP-429:+Kafka+Consumer+Incremental+Rebalance+Protocol#KIP429:KafkaConsumerIncrementalRebalanceProtocol-Consumer">请在此处</a>查看客户端升级路径指南以了解更多详细信息。</li>
<li>Scala<code>kafka.common.MessageFormatter</code>被删除了。请使用Java <code>org.apache.kafka.common.MessageFormatter</code>.</li>
<li>该<code>MessageFormatter.init(Properties)</code>方法已被删除。请改用<code>configure(Map)</code>。</li>
<li>该<code>checksum()</code>方法已从<code>ConsumerRecord</code>和中删除<code>RecordMetadata</code>。消息格式 v2（从 0.11 开始一直是默认格式）将校验和从记录移至记录批次。因此，这些方法没有意义，也不存在替代方法。</li>
<li>该类<code>ChecksumMessageFormatter</code>已被删除。它不是公共 API 的一部分，但可能已与<code>kafka-console-consumer.sh</code>. 它报告了每条记录的校验和，自消息格式 v2 以来不再支持该校验和。</li>
<li>该类<code>org.apache.kafka.clients.consumer.internals.PartitionAssignor</code>已被删除。请改用 <code>org.apache.kafka.clients.consumer.ConsumerPartitionAssignor</code>。</li>
<li>和配置已被删除 ( <code>quota.producer.default</code>KAFKA <a href="https://issues.apache.org/jira/browse/KAFKA-12591">-12591</a> )。必须改用动态配额默认值。<code>quota.consumer.default</code><a href="https://issues.apache.org/jira/browse/KAFKA-12591"></a></li>
<li>和配置已被<code>port</code>删除<code>host.name</code>。请改用<code>listeners</code>。</li>
<li>和配置已被<code>advertised.port</code>删除<code>advertised.host.name</code>。请改用<code>advertised.listeners</code>。</li>
<li>
<p>已弃用的工作程序配置<code>rest.host.name</code>已从Kafka Connect 工作程序配置中<code>rest.port</code>删除 ( <a href="https://issues.apache.org/jira/browse/KAFKA-12482">KAFKA-12482 )。</a>请改用<code>listeners</code>。</p>
</li>
<li>
<p>该<code>Producer#sendOffsetsToTransaction(Map offsets, String consumerGroupId)</code>方法已被弃用。请 <code>Producer#sendOffsetsToTransaction(Map offsets, ConsumerGroupMetadata metadata)</code>改用，其中<code>ConsumerGroupMetadata</code> 可以通过 检索<code>KafkaConsumer#groupMetadata()</code>以获得更强的语义。请注意，完整的消费者组元数据集只有代理或 2.5 或更高版本才能理解，因此您必须升级您的 kafka 集群以获得更强大的语义。否则，您可以直接<code>new ConsumerGroupMetadata(consumerGroupId)</code>与老broker合作。有关更多详细信息， 请参阅<a href="https://cwiki.apache.org/confluence/x/zJONCg">KIP-732 。</a></p>
</li>
<li>连接<code>internal.key.converter</code>和<code>internal.value.converter</code>属性已被完全<a href="https://cwiki.apache.org/confluence/x/2YDOCg">删除</a>。自版本 2.0.0 以来，已弃用这些 Connect 工作线程属性的使用。现在，工作人员被硬编码为使用 JSON 转换器并<code>schemas.enable</code>设置为<code>false</code>。<a href="https://cwiki.apache.org/confluence/x/2YDOCg">如果您的集群一直在使用不同的内部键或值转换器，您可以按照KIP-738</a>中概述的迁移步骤 将 Connect 集群安全升级到 3.0。</li>
<li>基于 Connect 的 MirrorMaker (MM2) 包括对支持的更改<code>IdentityReplicationPolicy</code>，无需重命名主题即可实现复制。默认情况下仍使用现有的<code>DefaultReplicationPolicy</code>，但可以通过 <code>replication.policy</code>配置属性启用身份复制。这对于从较旧的 MirrorMaker (MM1) 迁移的用户，或者对于具有简单单向复制拓扑且不希望主题重命名的用例特别有用。请注意<code>IdentityReplicationPolicy</code>，与 不同 <code>DefaultReplicationPolicy</code>， 无法阻止基于主题名称的复制循环，因此在构建复制拓扑时请注意避免循环。</li>
<li>最初的 MirrorMaker (MM1) 和相关类已被弃用。请使用基于 Connect 的 MirrorMaker (MM2)，如 <a href="https://kafka.apache.org/35/documentation/#georeplication">异地复制部分</a>中所述。</li>
</ul>
<h3 id="08x-27x-281">从 0.8.x 到 2.7.x 的任何版本升级到 2.8.1</h3>
<p><strong>如果您要从 2.1.x 之前的版本升级，请参阅下面有关用于存储消费者偏移量的架构更改的注释。一旦您将 inter.broker.protocol.version 更改为最新版本，将无法降级到 2.1 之前的版本。</strong></p>
<p><strong>对于滚动升级：</strong></p>
<ol>
<li>
<p>更新所有代理上的 server.properties 并添加以下属性。CURRENT_KAFKA_VERSION 是指您要升级的版本。CURRENT_MESSAGE_FORMAT_VERSION 指当前使用的消息格式版本。如果您之前已覆盖消息格式版本，则应保留其当前值。或者，如果您要从 0.11.0.x 之前的版本升级，则应将 CURRENT_MESSAGE_FORMAT_VERSION 设置为与 CURRENT_KAFKA_VERSION 匹配。</p>
<ul>
<li>inter.broker.protocol.version=CURRENT_KAFKA_VERSION （例如<code>2.7</code>、<code>2.6</code>等）</li>
<li>log.message.format.version=CURRENT_MESSAGE_FORMAT_VERSION（有关此配置的详细信息，请参阅<a href="https://kafka.apache.org/documentation/#upgrade_10_performance_impact">升级后的潜在性能影响。）</a></li>
</ul>
<p>如果您从0.11.0.x或更高版本升级，并且没有覆盖消息格式，那么您只需要覆盖代理间协议版本。
*   inter.broker.protocol.version=CURRENT_KAFKA_VERSION （例如<code>2.7</code>、<code>2.6</code>等）
2.  一次升级一个代理：关闭代理，更新代码，然后重新启动。完成此操作后，代理将运行最新版本，您可以验证集群的行为和性能是否符合预期。如果出现任何问题，此时仍然可以降级。
3.  验证集群的行为和性能后，通过编辑协议版本 <code>inter.broker.protocol.version</code>并将其设置为 来提升协议版本<code>2.8</code>。
4.  一一重启broker，新协议版本即可生效。一旦代理开始使用最新的协议版本，就无法再将集群降级到旧版本。
5.  如果您已按照上述说明覆盖消息格式版本，则需要再进行一次滚动重启才能将其升级到最新版本。一旦所有（或大多数）消费者升级到 0.11.0 或更高版本，将每个代理上的 log.message.format.version 更改为 2.8 并一一重新启动它们。请注意，不再维护的旧版 Scala 客户端不支持 0.11 中引入的消息格式，因此为了避免转换成本（或利用<a href="https://kafka.apache.org/documentation/#upgrade_11_exactly_once_semantics">恰好一次语义</a>），必须使用较新的 Java 客户端。</p>
</li>
</ol>
<h4 id="280">2.8.0 中的显着变化</h4>
<ul>
<li><a href="https://cwiki.apache.org/confluence/display/KAFKA/KIP-679%3A+Producer+will+enable+the+strongest+delivery+guarantee+by+default">2.8.0 版本向KIP-679</a> 中引入的授权者接口添加了一个新方法 。其动机是解锁我们未来的计划，以默认启用最强的消息传递保证。自定义授权者应考虑提供更有效的实现，支持审核日志记录和任何自定义配置或访问规则。</li>
<li><a href="https://cwiki.apache.org/confluence/display/KAFKA/KIP-516%3A+Topic+Identifiers">IBP 2.8 将主题 ID 作为KIP-516</a> 的一部分引入主题 。使用 ZooKeeper 时，此信息存储在 TopicZNode 中。如果集群降级到以前的 IBP 或版本，未来的主题将不会获得主题 ID，并且不保证主题将在 ZooKeeper 中保留其主题 ID。这意味着再次升级时，某些主题或所有主题将被分配新的 ID。</li>
<li>Kafka Streams 引入了类型安全<code>split()</code>运算符作为已弃用方法的替代<code>KStream#branch()</code>（参见<a href="https://cwiki.apache.org/confluence/display/KAFKA/KIP-418%3A+A+method-chaining+way+to+branch+KStream">KIP-418</a>）。</li>
</ul>
<h3 id="08x-26x-270">从 0.8.x 到 2.6.x 的任何版本升级到 2.7.0</h3>
<p><strong>如果您要从 2.1.x 之前的版本升级，请参阅下面有关用于存储消费者偏移量的架构更改的注释。一旦您将 inter.broker.protocol.version 更改为最新版本，将无法降级到 2.1 之前的版本。</strong></p>
<p><strong>对于滚动升级：</strong></p>
<ol>
<li>
<p>更新所有代理上的 server.properties 并添加以下属性。CURRENT_KAFKA_VERSION 是指您要升级的版本。CURRENT_MESSAGE_FORMAT_VERSION 指当前使用的消息格式版本。如果您之前已覆盖消息格式版本，则应保留其当前值。或者，如果您要从 0.11.0.x 之前的版本升级，则应将 CURRENT_MESSAGE_FORMAT_VERSION 设置为与 CURRENT_KAFKA_VERSION 匹配。</p>
<ul>
<li>inter.broker.protocol.version=CURRENT_KAFKA_VERSION （例如<code>2.6</code>、<code>2.5</code>等）</li>
<li>log.message.format.version=CURRENT_MESSAGE_FORMAT_VERSION（有关此配置的详细信息，请参阅<a href="https://kafka.apache.org/documentation/#upgrade_10_performance_impact">升级后的潜在性能影响。）</a></li>
</ul>
<p>如果您从0.11.0.x或更高版本升级，并且没有覆盖消息格式，那么您只需要覆盖代理间协议版本。
*   inter.broker.protocol.version=CURRENT_KAFKA_VERSION （例如<code>2.6</code>、<code>2.5</code>等）
2.  一次升级一个代理：关闭代理，更新代码，然后重新启动。完成此操作后，代理将运行最新版本，您可以验证集群的行为和性能是否符合预期。如果出现任何问题，此时仍然可以降级。
3.  验证集群的行为和性能后，通过编辑协议版本 <code>inter.broker.protocol.version</code>并将其设置为 来提升协议版本<code>2.7</code>。
4.  一一重启broker，新协议版本即可生效。一旦代理开始使用最新的协议版本，就无法再将集群降级到旧版本。
5.  如果您已按照上述说明覆盖消息格式版本，则需要再进行一次滚动重启才能将其升级到最新版本。一旦所有（或大多数）消费者升级到 0.11.0 或更高版本，将每个代理上的 log.message.format.version 更改为 2.7 并一一重新启动它们。请注意，不再维护的旧版 Scala 客户端不支持 0.11 中引入的消息格式，因此为了避免转换成本（或利用<a href="https://kafka.apache.org/documentation/#upgrade_11_exactly_once_semantics">恰好一次语义</a>），必须使用较新的 Java 客户端。</p>
</li>
</ol>
<h4 id="270">2.7.0 中的显着变化</h4>
<ul>
<li>2.7.0 版本包含 <a href="https://cwiki.apache.org/confluence/display/KAFKA/KIP-595%3A+A+Raft+Protocol+for+the+Metadata+Quorum">KIP-595</a>中指定的核心 Raft 实现。有一个单独的“raft”模块包含大部分逻辑。在与控制器的集成完成之前，用户可以使用一个独立的服务器来测试 Raft 实现的性能。详细信息请参见 raft 模块中的 README.md</li>
<li>KIP-651添加了 对使用 PEM 文件进行密钥和信任存储的 <a href="https://cwiki.apache.org/confluence/display/KAFKA/KIP-651+-+Support+PEM+format+for+SSL+certificates+and+private+key">支持。</a></li>
<li>KIP-612添加了 对强制代理范围和每个侦听器连接创建速率的<a href="https://cwiki.apache.org/confluence/display/KAFKA/KIP-612%3A+Ability+to+Limit+Connection+Creation+Rate+on+Brokers">支持。</a>2.7.0 版本包含 KIP-612 的第一部分，动态配置将在 2.8.0 版本中出现。</li>
<li>能够限制主题和分区创建或主题删除，以防止集群因 <a href="https://cwiki.apache.org/confluence/display/KAFKA/KIP-599%3A+Throttle+Create+Topic%2C+Create+Partition+and+Delete+Topic+Operations">KIP-599受到损害</a></li>
<li>
<p>当 Kafka 推出新功能时，存在两个主要问题：</p>
<ol>
<li>Kafka 客户端如何了解代理功能？</li>
<li>经纪商如何决定启用哪些功能？</li>
</ol>
<p><a href="https://cwiki.apache.org/confluence/display/KAFKA/KIP-584%3A+Versioning+scheme+for+features">KIP-584</a> 提供了灵活且易于操作的解决方案，只需一次重启即可实现客户端发现、功能门控和滚动升级。
*   <code>ConsoleConsumer</code>现在可以通过<a href="https://cwiki.apache.org/confluence/display/KAFKA/KIP-431%3A+Support+of+printing+additional+ConsumerRecord+fields+in+DefaultMessageFormatter">KIP-431</a> 打印记录偏移量和标题<a href="https://cwiki.apache.org/confluence/display/KAFKA/KIP-431%3A+Support+of+printing+additional+ConsumerRecord+fields+in+DefaultMessageFormatter"></a>
*   <a href="https://cwiki.apache.org/confluence/display/KAFKA/KIP-554%3A+Add+Broker-side+SCRAM+Config+API">KIP-554</a> 的添加 继续朝着从 Kafka 中删除 Zookeeper 的目标迈进。添加 KIP-554 意味着您不必再直接连接到 ZooKeeper 来管理 SCRAM 凭证。
*   更改现有侦听器的不可重新配置的配置会导致<code>InvalidRequestException</code>. 相比之下，之前的（意外的）行为会导致更新的配置被保留，但直到代理重新启动后才会生效。有关更多讨论，请参阅<a href="https://github.com/apache/kafka/pull/9284">KAFKA-10479 。</a>请参阅<code>DynamicBrokerConfig.DynamicSecurityConfigs</code>和<code>SocketServer.ListenerReconfigurableConfigs</code> 了解现有侦听器支持的可重新配置配置。
*   Kafka Streams 在 KStreams DSL 中 添加了对<a href="https://cwiki.apache.org/confluence/display/KAFKA/KIP-450%3A+Sliding+Window+Aggregations+in+the+DSL">滑动 Windows 聚合的支持。</a>
*   <a href="https://cwiki.apache.org/confluence/display/KAFKA/KIP-617%3A+Allow+Kafka+Streams+State+Stores+to+be+iterated+backwards">状态存储上的反向迭代可使用KIP-617</a> 实现更高效的最新更新搜索<a href="https://cwiki.apache.org/confluence/display/KAFKA/KIP-617%3A+Allow+Kafka+Streams+State+Stores+to+be+iterated+backwards"></a>
*   Kafka Steams 中的端到端延迟指标请参阅 <a href="https://cwiki.apache.org/confluence/display/KAFKA/KIP-613%3A+Add+end-to-end+latency+metrics+to+Streams">KIP-613</a> 了解更多详细信息
*   <a href="https://cwiki.apache.org/confluence/display/KAFKA/KIP-607%3A+Add+Metrics+to+Kafka+Streams+to+Report+Properties+of+RocksDB">Kafka Streams 添加了使用KIP-607</a> 报告默认 RocksDB 属性的指标<a href="https://cwiki.apache.org/confluence/display/KAFKA/KIP-607%3A+Add+Metrics+to+Kafka+Streams+to+Report+Properties+of+RocksDB"></a>
*   <a href="https://cwiki.apache.org/confluence/display/KAFKA/KIP-616%3A+Rename+implicit+Serdes+instances+in+kafka-streams-scala">KIP-616</a> 提供更好的 Scala 隐式 Serdes 支持<a href="https://cwiki.apache.org/confluence/display/KAFKA/KIP-616%3A+Rename+implicit+Serdes+instances+in+kafka-streams-scala"></a></p>
</li>
</ul>
<h3 id="08x-25x-260">从 0.8.x 到 2.5.x 的任何版本升级到 2.6.0</h3>
<p><strong>如果您要从 2.1.x 之前的版本升级，请参阅下面有关用于存储消费者偏移量的架构更改的注释。一旦您将 inter.broker.protocol.version 更改为最新版本，将无法降级到 2.1 之前的版本。</strong></p>
<p><strong>对于滚动升级：</strong></p>
<ol>
<li>
<p>更新所有代理上的 server.properties 并添加以下属性。CURRENT_KAFKA_VERSION 是指您要升级的版本。CURRENT_MESSAGE_FORMAT_VERSION 指当前使用的消息格式版本。如果您之前已覆盖消息格式版本，则应保留其当前值。或者，如果您要从 0.11.0.x 之前的版本升级，则应将 CURRENT_MESSAGE_FORMAT_VERSION 设置为与 CURRENT_KAFKA_VERSION 匹配。</p>
<ul>
<li>inter.broker.protocol.version=CURRENT_KAFKA_VERSION （例如<code>2.5</code>、<code>2.4</code>等）</li>
<li>log.message.format.version=CURRENT_MESSAGE_FORMAT_VERSION（有关此配置的详细信息，请参阅<a href="https://kafka.apache.org/documentation/#upgrade_10_performance_impact">升级后的潜在性能影响。）</a></li>
</ul>
<p>如果您从0.11.0.x或更高版本升级，并且没有覆盖消息格式，那么您只需要覆盖代理间协议版本。
*   inter.broker.protocol.version=CURRENT_KAFKA_VERSION （例如<code>2.5</code>、<code>2.4</code>等）
2.  一次升级一个代理：关闭代理，更新代码，然后重新启动。完成此操作后，代理将运行最新版本，您可以验证集群的行为和性能是否符合预期。如果出现任何问题，此时仍然可以降级。
3.  验证集群的行为和性能后，通过编辑协议版本 <code>inter.broker.protocol.version</code>并将其设置为 来提升协议版本<code>2.6</code>。
4.  一一重启broker，新协议版本即可生效。一旦代理开始使用最新的协议版本，就无法再将集群降级到旧版本。
5.  如果您已按照上述说明覆盖消息格式版本，则需要再进行一次滚动重启才能将其升级到最新版本。一旦所有（或大多数）消费者升级到 0.11.0 或更高版本，将每个代理上的 log.message.format.version 更改为 2.6 并一一重新启动它们。请注意，不再维护的旧版 Scala 客户端不支持 0.11 中引入的消息格式，因此为了避免转换成本（或利用<a href="https://kafka.apache.org/documentation/#upgrade_11_exactly_once_semantics">恰好一次语义</a>），必须使用较新的 Java 客户端。</p>
</li>
</ol>
<h4 id="260">2.6.0 中的显着变化</h4>
<ul>
<li>Kafka Streams 添加了一种新的处理模式（需要代理 2.5 或更高版本），该模式使用一次性保证提高应用程序可扩展性（参见<a href="https://cwiki.apache.org/confluence/display/KAFKA/KIP-447%3A+Producer+scalability+for+exactly+once+semantics">KIP-447</a>）</li>
<li>Java 11 或更高版本默认启用 TLSv1.3。如果客户端和服务器都支持 TLSv1.3，则将协商 TLSv1.3，否则回退到 TLSv1.2。有关更多详细信息， 请参阅 <a href="https://cwiki.apache.org/confluence/display/KAFKA/KIP-573%3A+Enable+TLSv1.3+by+default">KIP-573 。</a></li>
<li>配置的默认值<code>client.dns.lookup</code>已从 更改<code>default</code> 为<code>use_all_dns_ips</code>。如果主机名解析为多个 IP 地址，客户端和代理现在将尝试按顺序连接到每个 IP，直到成功建立连接。 有关更多详细信息， 请参阅 <a href="https://cwiki.apache.org/confluence/display/KAFKA/KIP-602%3A+Change+default+value+for+client.dns.lookup">KIP-602 。</a></li>
<li><code>NotLeaderForPartitionException</code>已被弃用并替换为<code>NotLeaderOrFollowerException</code>. 如果代理不是副本，则仅针对领导者或追随者的获取请求和其他请求将返回 NOT_LEADER_OR_FOLLOWER(6) 而不是 REPLICA_NOT_AVAILABLE(9)，确保所有客户端将重新分配期间的短暂错误作为可重试异常进行处理。</li>
</ul>
<h3 id="08x-24x-250">从 0.8.x 到 2.4.x 的任何版本升级到 2.5.0</h3>
<p><strong>如果您要从 2.1.x 之前的版本升级，请参阅下面有关用于存储消费者偏移量的架构更改的注释。一旦您将 inter.broker.protocol.version 更改为最新版本，将无法降级到 2.1 之前的版本。</strong></p>
<p><strong>对于滚动升级：</strong></p>
<ol>
<li>
<p>更新所有代理上的 server.properties 并添加以下属性。CURRENT_KAFKA_VERSION 是指您要升级的版本。CURRENT_MESSAGE_FORMAT_VERSION 指当前使用的消息格式版本。如果您之前已覆盖消息格式版本，则应保留其当前值。或者，如果您要从 0.11.0.x 之前的版本升级，则应将 CURRENT_MESSAGE_FORMAT_VERSION 设置为与 CURRENT_KAFKA_VERSION 匹配。</p>
<ul>
<li>inter.broker.protocol.version=CURRENT_KAFKA_VERSION （例如<code>2.4</code>、<code>2.3</code>等）</li>
<li>log.message.format.version=CURRENT_MESSAGE_FORMAT_VERSION（有关此配置的详细信息，请参阅<a href="https://kafka.apache.org/documentation/#upgrade_10_performance_impact">升级后的潜在性能影响。）</a></li>
</ul>
<p>如果您从0.11.0.x或更高版本升级，并且没有覆盖消息格式，那么您只需要覆盖代理间协议版本。
*   inter.broker.protocol.version=CURRENT_KAFKA_VERSION （例如<code>2.4</code>、<code>2.3</code>等）
2.  一次升级一个代理：关闭代理，更新代码，然后重新启动。完成此操作后，代理将运行最新版本，您可以验证集群的行为和性能是否符合预期。如果出现任何问题，此时仍然可以降级。
3.  验证集群的行为和性能后，通过编辑协议版本 <code>inter.broker.protocol.version</code>并将其设置为 来提升协议版本<code>2.5</code>。
4.  一一重启broker，新协议版本即可生效。一旦代理开始使用最新的协议版本，就无法再将集群降级到旧版本。
5.  如果您已按照上述说明覆盖消息格式版本，则需要再进行一次滚动重启才能将其升级到最新版本。一旦所有（或大多数）消费者升级到 0.11.0 或更高版本，将每个代理上的 log.message.format.version 更改为 2.5 并一一重新启动它们。请注意，不再维护的旧版 Scala 客户端不支持 0.11 中引入的消息格式，因此为了避免转换成本（或利用<a href="https://kafka.apache.org/documentation/#upgrade_11_exactly_once_semantics">恰好一次语义</a>），必须使用较新的 Java 客户端。
6.  <a href="https://cwiki.apache.org/confluence/display/KAFKA/KIP-455%3A+Create+an+Administrative+API+for+Replica+Reassignment">KIP-455</a><code>kafka-reassign-partitions.sh</code> 完成后， 重新分配工具发生了一些显着的变化。该工具现在要求在更改主动重新分配的限制时提供标志。现在可以使用该 命令取消重新分配。最后，重新分配 已被弃用，取而代之的是。有关更多详细信息，请参阅 KIP。 <a href="https://cwiki.apache.org/confluence/display/KAFKA/KIP-455%3A+Create+an+Administrative+API+for+Replica+Reassignment"></a><code>--additional``--cancel``--zookeeper``--bootstrap-server</code></p>
</li>
</ol>
<h4 id="250">2.5.0 中的显着变化</h4>
<ul>
<li>当<code>RebalanceProtocol#COOPERATIVE</code>使用时，<code>Consumer#poll</code>当它处于消费者仍然拥有的那些分区的重新平衡过程中时，仍然可以返回数据；此外 <code>Consumer#commitSync</code>，现在可能会抛出一个非致命<code>RebalanceInProgressException</code>事件来通知用户此类事件，以便与致命事件区分开来<code>CommitFailedException</code>并允许用户完成正在进行的重新平衡，然后重新尝试为那些仍然拥有的分区提交偏移量。</li>
<li>为了提高典型网络环境中的弹性，默认值 <code>zookeeper.session.timeout.ms</code>已从 6 秒增加到 18 秒， <code>replica.lag.time.max.ms</code>从 10 秒增加到 30 秒。</li>
<li><code>cogroup()</code>添加了新的 DSL 运算符，用于一次将多个流聚合在一起。</li>
<li>添加了一个新的<code>KStream.toTable()</code>API，用于将输入事件流转换为 KTable。</li>
<li>添加了新的 Serde 类型<code>Void</code>来表示输入主题中的空键或空值。</li>
<li>已弃用<code>UsePreviousTimeOnInvalidTimestamp</code>并替换为<code>UsePartitionTimeOnInvalidTimeStamp</code>.</li>
<li>通过添加挂起的偏移防护机制和更强的事务提交一致性检查来改进精确一次语义，这极大地简化了可扩展的精确一次应用程序的实现。<a href="https://github.com/apache/kafka/tree/2.5/examples">我们还在示例</a>文件夹下添加了一个新的一次性语义代码示例 。查看 <a href="https://cwiki.apache.org/confluence/display/KAFKA/KIP-447%3A+Producer+scalability+for+exactly+once+semantics">KIP-447</a> 了解完整详细信息。</li>
<li>添加了新的公共 api<code>KafkaStreams.queryMetadataForKey(String, K, Serializer) to get detailed information on the key being queried. It provides information about the partition number where the key resides in addition to hosts containing the active and standby partitions for the key.</code></li>
<li>通过弃用并将<code>KafkaStreams.store(String, QueryableStoreType)</code>其替换为<code>KafkaStreams.store(StoreQueryParameters)</code>.</li>
<li>添加了一个新的公共 api，用于访问实例本地存储的滞后信息<code>KafkaStreams.allLocalStorePartitionLags()</code>。</li>
<li>不再支持 Scala 2.11。详细信息请参阅 <a href="https://cwiki.apache.org/confluence/display/KAFKA/KIP-531%3A+Drop+support+for+Scala+2.11+in+Kafka+2.5">KIP-531</a> 。</li>
<li>包中的所有 Scala 类<code>kafka.security.auth</code>均已弃用。 有关 2.4.0 中添加的新 Java 授权者 API 的详细信息，请参阅 <a href="https://cwiki.apache.org/confluence/display/KAFKA/KIP-504+-+Add+new+Java+Authorizer+Interface">KIP-504 。</a>请注意，<code>kafka.security.auth.Authorizer</code> 和<code>kafka.security.auth.SimpleAclAuthorizer</code>在 2.4.0 中已弃用。</li>
<li>默认情况下，TLSv1 和 TLSv1.1 已被禁用，因为它们存在已知的安全漏洞。现在默认仅启用 TLSv1.2。<code>ssl.protocol</code>您可以通过在配置选项和 中显式启用 TLSv1 和 TLSv1.1 来继续使用它们 <code>ssl.enabled.protocols</code>。</li>
<li>ZooKeeper 已升级到 3.5.7，如果 3.4 数据目录中没有快照文件，ZooKeeper 从 3.4.X 升级到 3.5.7 可能会失败。这通常发生在测试升级中，其中 ZooKeeper 3.5.7 尝试加载尚未创建快照文件的现有 3.4 数据目录。有关该问题的更多详细信息，请参阅<a href="https://issues.apache.org/jira/browse/ZOOKEEPER-3056">ZOOKEEPER-3056</a>。<a href="https://issues.apache.org/jira/browse/ZOOKEEPER-3056">ZOOKEEPER-3056</a>中给出了修复，即在升级之前 设置<code>snapshot.trust.empty=true</code> 配置。<code>zookeeper.properties</code></li>
<li>ZooKeeper 版本 3.5.7 支持使用或不使用客户端证书与 ZooKeeper 进行 TLS 加密连接，并且可以使用其他 Kafka 配置来利用此功能。详细信息请参阅<a href="https://cwiki.apache.org/confluence/display/KAFKA/KIP-515%3A+Enable+ZK+client+to+use+the+new+TLS+supported+authentication">KIP-515</a>。</li>
</ul>
<h3 id="08x09x0100x0101x0102x0110x10x11x20x-21x-22x-23x-240">从 0.8.x、0.9.x、0.10.0.x、0.10.1.x、0.10.2.x、0.11.0.x、1.0.x、1.1.x、2.0.x 或 2.1.x 升级，或者2.2.x 或 2.3.x 至 2.4.0</h3>
<p><strong>如果您要从 2.1.x 之前的版本升级，请参阅下面有关用于存储消费者偏移量的架构更改的注释。一旦您将 inter.broker.protocol.version 更改为最新版本，将无法降级到 2.1 之前的版本。</strong></p>
<p><strong>对于滚动升级：</strong></p>
<ol>
<li>
<p>更新所有代理上的 server.properties 并添加以下属性。CURRENT_KAFKA_VERSION 是指您要升级的版本。CURRENT_MESSAGE_FORMAT_VERSION 指当前使用的消息格式版本。如果您之前已覆盖消息格式版本，则应保留其当前值。或者，如果您要从 0.11.0.x 之前的版本升级，则应将 CURRENT_MESSAGE_FORMAT_VERSION 设置为与 CURRENT_KAFKA_VERSION 匹配。</p>
<ul>
<li>inter.broker.protocol.version=CURRENT_KAFKA_VERSION（例如0.10.0、0.11.0、1.0、2.0、2.2）。</li>
<li>log.message.format.version=CURRENT_MESSAGE_FORMAT_VERSION（有关此配置的详细信息，请参阅<a href="https://kafka.apache.org/documentation/#upgrade_10_performance_impact">升级后的潜在性能影响。）</a></li>
</ul>
<p>如果您从0.11.0.x或更高版本升级，并且没有覆盖消息格式，那么您只需要覆盖代理间协议版本。
*   inter.broker.protocol.version=CURRENT_KAFKA_VERSION（0.11.0、1.0、1.1、2.0、2.1、2.2、2.3）。
2.  一次升级一个代理：关闭代理，更新代码，然后重新启动。完成此操作后，代理将运行最新版本，您可以验证集群的行为和性能是否符合预期。如果出现任何问题，此时仍然可以降级。
3.  验证集群的行为和性能后，通过编辑 <code>inter.broker.protocol.version</code>并将其设置为 2.4 来提升协议版本。
4.  一一重启broker，新协议版本即可生效。一旦代理开始使用最新的协议版本，就无法再将集群降级到旧版本。
5.  如果您已按照上述说明覆盖消息格式版本，则需要再进行一次滚动重启才能将其升级到最新版本。一旦所有（或大多数）消费者升级到 0.11.0 或更高版本，将每个代理上的 log.message.format.version 更改为 2.4 并一一重新启动它们。请注意，不再维护的旧版 Scala 客户端不支持 0.11 中引入的消息格式，因此为了避免转换成本（或利用<a href="https://kafka.apache.org/documentation/#upgrade_11_exactly_once_semantics">恰好一次语义</a>），必须使用较新的 Java 客户端。</p>
</li>
</ol>
<p><strong>附加升级说明：</strong></p>
<ol>
<li>ZooKeeper已升级至3.5.6。如果 3.4 数据目录中没有快照文件，ZooKeeper 从 3.4.X 升级到 3.5.6 可能会失败。这通常发生在测试升级中，其中 ZooKeeper 3.5.6 尝试加载尚未创建快照文件的现有 3.4 数据目录。有关该问题的更多详细信息，请参阅<a href="https://issues.apache.org/jira/browse/ZOOKEEPER-3056">ZOOKEEPER-3056</a>。<a href="https://issues.apache.org/jira/browse/ZOOKEEPER-3056">ZOOKEEPER-3056</a>中给出了修复，即在升级之前设置<code>snapshot.trust.empty=true</code> 配置。<code>zookeeper.properties</code>但我们观察到使用 <code>snapshot.trust.empty=true</code>config.js 进行独立集群升级时会出现数据丢失的情况。有关该问题的更多详细信息，请参阅<a href="https://issues.apache.org/jira/browse/ZOOKEEPER-3644">ZOOKEEPER-3644</a>。<a href="https://issues.apache.org/jira/secure/attachment/12928686/snapshot.0">因此，我们建议使用复制空快照</a>的安全解决方法<a href="https://issues.apache.org/jira/secure/attachment/12928686/snapshot.0"></a>如果3.4数据目录中没有快照文件，则将文件复制到3.4数据目录中。有关解决方法的更多详细信息，请参阅<a href="https://cwiki.apache.org/confluence/display/ZOOKEEPER/Upgrade+FAQ">ZooKeeper 升级常见问题解答</a>。</li>
<li>ZooKeeper 3.5 中添加了 基于嵌入式 Jetty 的<a href="http://zookeeper.apache.org/doc/r3.5.6/zookeeperAdmin.html#sc_adminserver">AdminServer 。</a><code>zookeeper.properties</code>AdminServer 在 ZooKeeper 中默认启用，并在端口 8080 上启动。AdminServer 在Apache Kafka 发行版提供的ZooKeeper 配置 ( ) 中默认禁用。如果您想禁用管理服务器，请确保更新您的本地<code>zookeeper.properties</code>文件。<code>admin.enableServer=false</code>请参考<a href="http://zookeeper.apache.org/doc/r3.5.6/zookeeperAdmin.html#sc_adminserver">AdminServer 配置</a>来配置 AdminServer。</li>
</ol>
<h4 id="240">2.4.0 中的显着变化</h4>
<ul>
<li>添加了新的管理 API，用于分区重新分配。由于改变了 Kafka 传播重新分配信息的方式，因此在升级到新版本时，在故障边缘情况下可能会丢失重新分配状态。不建议在升级时开始重新分配。</li>
<li>ZooKeeper已从3.4.14升级到3.5.6。新版本支持TLS和动态重新配置。</li>
<li>命令<code>bin/kafka-preferred-replica-election.sh</code>行工具已被弃用。它已被替换为<code>bin/kafka-leader-election.sh</code>.</li>
<li><code>electPreferredLeaders</code>Java 类中的方法<code>AdminClient</code>已被弃用，取而代之的是方法<code>electLeaders</code>。</li>
<li>利用带有文字值的构造函数的 Scala 代码<code>NewTopic(String, int, short)</code>需要显式调用<code>toShort</code>第二个文字。</li>
<li>构造函数中的参数<code>GroupAuthorizationException(String)</code>现在用于指定异常消息。以前它指的是授权失败的组。这样做是为了与其他异常类型保持一致并避免潜在的误用。<code>TopicAuthorizationException(String)</code>之前用于单个未授权主题的 构造函数也进行了类似的更改。</li>
<li>内部<code>PartitionAssignor</code>接口已被弃用，并替换为新的<code>ConsumerPartitionAssignor</code>公共 API。两个接口之间的某些方法/签名略有不同。实现自定义 PartitionAssignor 的用户应尽快迁移到新界面。</li>
<li>现在<code>DefaultPartitioner</code>使用粘性分区策略。这意味着具有空键且未分配分区的特定主题的记录将被发送到同一分区，直到准备好发送批次为止。创建新批次时，会选择一个新分区。这减少了生成延迟，但可能会导致边缘情况下记录在分区之间分布不均匀。一般来说，用户不会受到影响，但在测试和其他在很短的时间内生成记录的情况下，这种差异可能会很明显。</li>
<li>阻塞<code>KafkaConsumer#committed</code>方法已扩展为允许分区列表作为输入参数，而不是单个分区。它可以减少客户端和代理之间为消费者组获取已提交偏移量的请求/响应迭代。旧的重载函数已被弃用，我们建议用户更改代码以利用新方法（详细信息可以在<a href="https://cwiki.apache.org/confluence/display/KAFKA/KIP-520%3A+Add+overloaded+Consumer%23committed+for+batching+partitions">KIP-520</a>中找到）。</li>
<li>我们<code>INVALID_RECORD</code>在生成响应中引入了一个新错误以与该<code>CORRUPT_MESSAGE</code>错误区分开。更具体地说，以前当一批记录作为单个请求的一部分发送到代理时，由于各种原因（魔术字节不匹配、crc 校验和错误、压缩日志的空键），一个或多个记录未能通过验证主题等），整个批次将被拒绝，并且具有相同和误导性<code>CORRUPT_MESSAGE</code>，并且生产者客户端的调用者将从<code>RecordMetadata</code>调用返回的未来对象<code>send</code>以及在<code>Callback#onCompletion(RecordMetadata metadata, Exception exception)</code> 现在，有了新的错误代码和改进的异常错误消息，生产者调用者可以更好地了解其发送记录失败的根本原因。</li>
<li>我们正在向客户端组协议引入增量合作重新平衡，该协议允许消费者在重新平衡期间保留所有分配的分区，并在最后仅撤销那些必须迁移到另一个消费者以实现整体集群平衡的分区。他们将选择 所有消费者支持的分配者普遍支持的<code>ConsumerCoordinator</code>最新版本。<code>RebalanceProtocol</code>您可以使用新的内置<code>CooperativeStickyAssignor</code>或插入您自己的自定义协作分配器。为此，您必须实现该<code>ConsumerPartitionAssignor</code>接口并包含<code>RebalanceProtocol.COOPERATIVE</code>在 . 返回的列表中<code>ConsumerPartitionAssignor#supportedProtocols</code>。然后，您的自定义分配者可以利用<code>ownedPartitions</code>每个消费者的字段<code>Subscription</code>尽可能将分区归还给以前的所有者。请注意，当要将分区重新分配给另一个使用者时，<em>必须</em>将其从新分配中删除，直到它从其原始所有者手中撤销。任何必须撤销分区的消费者都将触发后续重新平衡，以允许撤销的分区安全地分配给其新所有者。有关更多信息， 请参阅 <a href="https://kafka.apache.org/24/javadoc/index.html?org/apache/kafka/clients/consumer/ConsumerPartitionAssignor.RebalanceProtocol.html">ConsumerPartitionAssignor RebalanceProtocol javadocs 。</a><br />
    要从旧的（急切的）协议（在重新平衡之前总是撤销所有分区）升级到协作重新平衡，您必须遵循特定的升级路径以使所有客户端都处于同一状态<code>ConsumerPartitionAssignor</code> 支持合作协议。这可以通过两次滚动弹跳来完成，例如<code>CooperativeStickyAssignor</code>：在第一次弹跳期间，将“合作粘性”添加到每个成员支持的分配器列表中（不删除先前的分配器 - 请注意，如果之前使用默认分配器） ，您也必须明确包含该内容）。然后您可以退回和/或升级它。一旦整个组处于 2.4+ 并且所有成员在其支持的分配者之间都具有“合作粘性”，请删除其他分配者并执行第二次滚动反弹，以便最终所有成员仅支持合作协议。有关协作再平衡协议和升级路径的更多详细信息，请参阅<a href="https://cwiki.apache.org/confluence/x/vAclBg">KIP-429</a>。</li>
<li><code>ConsumerRebalanceListener</code>以及新的 API进行了一些行为更改。在侦听器的三个回调中的任何一个期间抛出的异常将不再被吞掉，而是会一直重新抛出直到调用为止<code>Consumer.poll()</code>。<code>onPartitionsLost</code>添加该方法是为了允许用户对消费者可能失去其分区所有权（例如错过重新平衡）并且无法提交偏移量的异常情况做出反应。默认情况下，这将简单地调用现有<code>onPartitionsRevoked</code>API 来与之前的行为保持一致。但请注意，<code>onPartitionsLost</code>当丢失的分区集为空时，不会调用该方法。这意味着在新消费者加入组的第一次重新平衡开始时不会调用回调。<br />
    的语义<code>ConsumerRebalanceListener's</code>当遵循上述合作再平衡协议时，回调会进一步改变。此外<code>onPartitionsLost</code>，<code>onPartitionsRevoked</code> 当撤销分区集为空时，也永远不会被调用。该回调通常仅在重新平衡结束时调用，并且仅在正在移动到另一个使用者的分区集上调用。然而，即使分区集为空，回调 <code>onPartitionsAssigned</code>也将始终被调用，作为通知用户重新平衡事件的一种方式（对于合作型和渴望型都是如此）。有关新回调语义的详细信息，请参阅<a href="https://kafka.apache.org/24/javadoc/index.html?org/apache/kafka/clients/consumer/ConsumerRebalanceListener.html">ConsumerRebalanceListener javadocs</a>。</li>
<li>Scala 特征<code>kafka.security.auth.Authorizer</code>已被弃用并被新的 Java API 取代 <code>org.apache.kafka.server.authorizer.Authorizer</code>。授权者实现类 <code>kafka.security.auth.SimpleAclAuthorizer</code>也已被弃用并被新的实现所取代<code>kafka.security.authorizer.AclAuthorizer</code>。<code>AclAuthorizer</code>使用新 API 支持的功能来改进授权日志记录，并与<code>SimpleAclAuthorizer</code>. 有关更多详细信息，请参阅<a href="https://cwiki.apache.org/confluence/display/KAFKA/KIP-504+-+Add+new+Java+Authorizer+Interface">KIP-504</a>。</li>
</ul>
<h3 id="08x09x0100x0101x0102x0110x10x11x20x-21x-22x-230">从 0.8.x、0.9.x、0.10.0.x、0.10.1.x、0.10.2.x、0.11.0.x、1.0.x、1.1.x、2.0.x 或 2.1.x 升级，或者2.2.x 至 2.3.0</h3>
<p><strong>如果您要从 2.1.x 之前的版本升级，请参阅下面有关用于存储消费者偏移量的架构更改的注释。一旦您将 inter.broker.protocol.version 更改为最新版本，将无法降级到 2.1 之前的版本。</strong></p>
<p><strong>对于滚动升级：</strong></p>
<ol>
<li>
<p>更新所有代理上的 server.properties 并添加以下属性。CURRENT_KAFKA_VERSION 是指您要升级的版本。CURRENT_MESSAGE_FORMAT_VERSION 指当前使用的消息格式版本。如果您之前已覆盖消息格式版本，则应保留其当前值。或者，如果您要从 0.11.0.x 之前的版本升级，则应将 CURRENT_MESSAGE_FORMAT_VERSION 设置为与 CURRENT_KAFKA_VERSION 匹配。</p>
<ul>
<li>inter.broker.protocol.version=CURRENT_KAFKA_VERSION（例如0.8.2、0.9.0、0.10.0、0.10.1、0.10.2、0.11.0、1.0、1.1）。</li>
<li>log.message.format.version=CURRENT_MESSAGE_FORMAT_VERSION（有关此配置的详细信息，请参阅<a href="https://kafka.apache.org/documentation/#upgrade_10_performance_impact">升级后的潜在性能影响。）</a></li>
</ul>
<p>如果您从 0.11.0.x、1.0.x、1.1.x、2.0.x 或 2.1.x 升级，并且尚未覆盖消息格式，则只需覆盖代理间协议版本。
*   inter.broker.protocol.version=CURRENT_KAFKA_VERSION（0.11.0、1.0、1.1、2.0、2.1、2.2）。
2.  一次升级一个代理：关闭代理，更新代码，然后重新启动。完成此操作后，代理将运行最新版本，您可以验证集群的行为和性能是否符合预期。如果出现任何问题，此时仍然可以降级。
3.  验证集群的行为和性能后，通过编辑 <code>inter.broker.protocol.version</code>并将其设置为 2.3 来提升协议版本。
4.  一一重启broker，新协议版本即可生效。一旦代理开始使用最新的协议版本，就无法再将集群降级到旧版本。
5.  如果您已按照上述说明覆盖消息格式版本，则需要再进行一次滚动重启才能将其升级到最新版本。一旦所有（或大多数）消费者升级到 0.11.0 或更高版本，将每个代理上的 log.message.format.version 更改为 2.3 并一一重新启动它们。请注意，不再维护的旧版 Scala 客户端不支持 0.11 中引入的消息格式，因此为了避免转换成本（或利用<a href="https://kafka.apache.org/documentation/#upgrade_11_exactly_once_semantics">恰好一次语义</a>），必须使用较新的 Java 客户端。</p>
</li>
</ol>
<h4 id="230">2.3.0 中的显着变化</h4>
<ul>
<li>我们正在为 Kafka Connect 引入一种基于 <a href="https://cwiki.apache.org/confluence/display/KAFKA/KIP-415%3A+Incremental+Cooperative+Rebalancing+in+Kafka+Connect">增量合作再平衡</a>的新再平衡协议。新协议不需要在 Connect 工作线程之间的重新平衡阶段停止所有任务。相反，只有需要在工作人员之间交换的任务才会停止，并在后续重新平衡中启动它们。从 2.3.0 开始，新的 Connect 协议默认启用。有关其工作原理以及如何启用急切再平衡的旧行为的更多详细信息，请查看 <a href="https://kafka.apache.org/35/documentation/#connect_administration">增量协作再平衡设计</a>。</li>
<li>我们正在向消费者用户引入静态会员资格。此功能减少了正常应用程序升级或滚动弹跳期间不必要的重新平衡。有关如何使用它的更多详细信息，请查看<a href="https://kafka.apache.org/35/documentation/#static_membership">静态成员资格设计</a>。</li>
<li>Kafka Streams DSL 切换其使用的存储类型。虽然此更改主要对用户是透明的，但在某些极端情况下可能需要更改代码。有关更多详细信息，请参阅<a href="https://kafka.apache.org/35/documentation/streams/upgrade-guide#streams_api_changes_230">Kafka Streams 升级部分</a>。</li>
<li>Kafka Streams 2.3.0 需要 0.11 消息格式或更高版本，并且不适用于较旧的消息格式。</li>
</ul>
<h3 id="08x09x0100x0101x0102x0110x10x11x20x-21x-220">从 0.8.x、0.9.x、0.10.0.x、0.10.1.x、0.10.2.x、0.11.0.x、1.0.x、1.1.x、2.0.x 或 2.1.x 升级到2.2.0</h3>
<p><strong>如果您要从 2.1.x 之前的版本升级，请参阅下面有关用于存储消费者偏移量的架构更改的注释。一旦您将 inter.broker.protocol.version 更改为最新版本，将无法降级到 2.1 之前的版本。</strong></p>
<p><strong>对于滚动升级：</strong></p>
<ol>
<li>
<p>更新所有代理上的 server.properties 并添加以下属性。CURRENT_KAFKA_VERSION 是指您要升级的版本。CURRENT_MESSAGE_FORMAT_VERSION 指当前使用的消息格式版本。如果您之前已覆盖消息格式版本，则应保留其当前值。或者，如果您要从 0.11.0.x 之前的版本升级，则应将 CURRENT_MESSAGE_FORMAT_VERSION 设置为与 CURRENT_KAFKA_VERSION 匹配。</p>
<ul>
<li>inter.broker.protocol.version=CURRENT_KAFKA_VERSION（例如0.8.2、0.9.0、0.10.0、0.10.1、0.10.2、0.11.0、1.0、1.1）。</li>
<li>log.message.format.version=CURRENT_MESSAGE_FORMAT_VERSION（有关此配置的详细信息，请参阅<a href="https://kafka.apache.org/documentation/#upgrade_10_performance_impact">升级后的潜在性能影响。）</a></li>
</ul>
<p>如果您从 0.11.0.x、1.0.x、1.1.x 或 2.0.x 升级并且尚未覆盖消息格式，则只需覆盖代理间协议版本。
*   inter.broker.protocol.version=CURRENT_KAFKA_VERSION（0.11.0、1.0、1.1、2.0）。
2.  一次升级一个代理：关闭代理，更新代码，然后重新启动。完成此操作后，代理将运行最新版本，您可以验证集群的行为和性能是否符合预期。如果出现任何问题，此时仍然可以降级。
3.  验证集群的行为和性能后，通过编辑 <code>inter.broker.protocol.version</code>并将其设置为 2.2 来提升协议版本。
4.  一一重启broker，新协议版本即可生效。一旦代理开始使用最新的协议版本，就无法再将集群降级到旧版本。
5.  如果您已按照上述说明覆盖消息格式版本，则需要再进行一次滚动重启才能将其升级到最新版本。一旦所有（或大多数）消费者升级到 0.11.0 或更高版本，将每个代理上的 log.message.format.version 更改为 2.2 并一一重新启动它们。请注意，不再维护的旧版 Scala 客户端不支持 0.11 中引入的消息格式，因此为了避免转换成本（或利用<a href="https://kafka.apache.org/documentation/#upgrade_11_exactly_once_semantics">恰好一次语义</a>），必须使用较新的 Java 客户端。</p>
</li>
</ol>
<h4 id="221">2.2.1 中的显着变化</h4>
<ul>
<li>Kafka Streams 2.2.1 需要 0.11 消息格式或更高版本，并且不适用于较旧的消息格式。</li>
</ul>
<h4 id="220">2.2.0 中的显着变化</h4>
<ul>
<li>默认消费者组 ID 已从空字符串 ( <code>""</code>) 更改为<code>null</code>。使用新的默认组 ID 的消费者将无法订阅主题、获取或提交偏移量。不推荐使用空字符串作为消费者组 ID，但在未来的主要版本之前将受支持。依赖空字符串组 ID 的旧客户端现在必须显式提供它作为其消费者配置的一部分。有关详细信息，请参阅 <a href="https://cwiki.apache.org/confluence/display/KAFKA/KIP-289%3A+Improve+the+default+group+id+behavior+in+KafkaConsumer">KIP-289</a>。</li>
<li>命令<code>bin/kafka-topics.sh</code>行工具现在可以直接连接到代理而<code>--bootstrap-server</code>不是zookeeper。旧<code>--zookeeper</code> 选项目前仍然可用。请阅读<a href="https://cwiki.apache.org/confluence/display/KAFKA/KIP-377%3A+TopicCommand+to+use+AdminClient">KIP-377</a>了解更多信息。</li>
<li>Kafka Streams 依赖于较新版本的 RocksDB，需要 MacOS 10.13 或更高版本。</li>
</ul>
<h3 id="08x09x0100x0101x0102x0110x10x11x-200-210httpskafkaapacheorgdocumentationupgrade_2_1_0">从 0.8.x、0.9.x、0.10.0.x、0.10.1.x、0.10.2.x、0.11.0.x、1.0.x、1.1.x 或 2.0.0 升级到 2.1.0](https://kafka.apache.org/documentation/#upgrade_2_1_0)</h3>
<p><strong>请注意，2.1.x 包含对用于存储消费者偏移量的内部架构的更改。升级完成后，将无法降级到之前的版本。有关更多详细信息，请参阅下面的滚动升级说明。</strong></p>
<p><strong>对于滚动升级：</strong></p>
<ol>
<li>
<p>更新所有代理上的 server.properties 并添加以下属性。CURRENT_KAFKA_VERSION 是指您要升级的版本。CURRENT_MESSAGE_FORMAT_VERSION 指当前使用的消息格式版本。如果您之前已覆盖消息格式版本，则应保留其当前值。或者，如果您要从 0.11.0.x 之前的版本升级，则应将 CURRENT_MESSAGE_FORMAT_VERSION 设置为与 CURRENT_KAFKA_VERSION 匹配。</p>
<ul>
<li>inter.broker.protocol.version=CURRENT_KAFKA_VERSION（例如0.8.2、0.9.0、0.10.0、0.10.1、0.10.2、0.11.0、1.0、1.1）。</li>
<li>log.message.format.version=CURRENT_MESSAGE_FORMAT_VERSION（有关此配置的详细信息，请参阅<a href="https://kafka.apache.org/documentation/#upgrade_10_performance_impact">升级后的潜在性能影响。）</a></li>
</ul>
<p>如果您从 0.11.0.x、1.0.x、1.1.x 或 2.0.x 升级并且尚未覆盖消息格式，则只需覆盖代理间协议版本。
*   inter.broker.protocol.version=CURRENT_KAFKA_VERSION（0.11.0、1.0、1.1、2.0）。
2.  一次升级一个代理：关闭代理，更新代码，然后重新启动。完成此操作后，代理将运行最新版本，您可以验证集群的行为和性能是否符合预期。如果出现任何问题，此时仍然可以降级。
3.  验证集群的行为和性能后，通过编辑 <code>inter.broker.protocol.version</code>并将其设置为 2.1 来提升协议版本。
4.  一一重启broker，新协议版本即可生效。一旦代理开始使用最新的协议版本，就无法再将集群降级到旧版本。
5.  如果您已按照上述说明覆盖消息格式版本，则需要再进行一次滚动重启才能将其升级到最新版本。一旦所有（或大多数）消费者升级到 0.11.0 或更高版本，将每个代理上的 log.message.format.version 更改为 2.1 并一一重新启动它们。请注意，不再维护的旧版 Scala 客户端不支持 0.11 中引入的消息格式，因此为了避免转换成本（或利用<a href="https://kafka.apache.org/documentation/#upgrade_11_exactly_once_semantics">恰好一次语义</a>），必须使用较新的 Java 客户端。</p>
</li>
</ol>
<p><strong>附加升级说明：</strong></p>
<ol>
<li>在此版本中，偏移过期语义略有变化。根据新的语义，当组订阅了相应的主题并且仍然处于活动状态（有活跃的消费者）时，组中分区的偏移量不会被删除。如果组变空，则在默认偏移保留期（或代理设置的保留期）过去后，其所有偏移将被删除（除非该组再次变为活动状态）。与不使用 Kafka 组管理的独立（简单）消费者相关的偏移量，将在自上次提交以来默认偏移量保留期（或由代理设置的保留期）过去后被删除。</li>
<li><code>enable.auto.commit</code>未提供时控制台使用者属性的默认值<code>group.id</code>现在设置为<code>false</code>。这是为了避免污染消费者协调器缓存，因为自动生成的组不太可能被其他消费者使用。</li>
<li>正如我们 在<a href="https://cwiki.apache.org/confluence/display/KAFKA/KIP-91+Provide+Intuitive+User+Timeouts+in+The+Producer">KIP-91</a>中介绍的那样，生产者<code>retries</code>配置的默认值已更改为，它设置了发送记录和从代理接收确认之间的总时间上限。默认情况下，传送超时设置为 2 分钟。<code>Integer.MAX_VALUE``delivery.timeout.ms</code><a href="https://cwiki.apache.org/confluence/display/KAFKA/KIP-91+Provide+Intuitive+User+Timeouts+in+The+Producer"></a></li>
<li>默认情况下，MirrorMaker 现在会在配置生产者时<code>delivery.timeout.ms</code>覆盖。如果您为了更快地失败<code>Integer.MAX_VALUE</code>而覆盖了 的值，则您将需要覆盖。<code>retries``delivery.timeout.ms</code></li>
<li><code>ListGroup</code>作为推荐的替代方案，API 现在期望访问<code>Describe Group</code>用户应该能够列出的组。尽管<code>Describe Cluster</code>仍支持旧的访问以实现向后兼容性，但不建议将其用于此 API。</li>
<li><a href="https://cwiki.apache.org/confluence/pages/viewpage.action?pageId=87298242">KIP-336</a>弃用了 ExtendedSerializer 和 ExtendedDeserializer 接口，并推广了 Serializer 和 Deserializer 的使用。<a href="https://cwiki.apache.org/confluence/display/KAFKA/KIP-82+-+Add+Record+Headers">ExtendedSerializer 和 ExtendedDeserializer 是随KIP-82</a>引入的， 以 Java 7 兼容的方式为序列化器和反序列化器提供记录标头。现在我们整合了这些接口，因为 Java 7 支持已被删除。</li>
</ol>
<h4 id="210">2.1.0 中的显着变化</h4>
<ul>
<li>Jetty 已升级到 9.4.12，默认情况下不包括 TLS_RSA_* 密码，因为它们不支持前向保密，有关更多信息，请参阅 https://github.com/eclipse/jetty.project/issues/2807。</li>
<li><code>unclean.leader.election.enable</code>当使用每个主题配置覆盖动态更新配置时，控制器会自动启用不干净的领导者选举。</li>
<li>添加<code>AdminClient</code>了一个方法<code>AdminClient#metrics()</code>。现在，任何使用 的应用程序都<code>AdminClient</code>可以通过查看从 捕获的指标来获得更多信息和见解<code>AdminClient</code>。欲了解更多信息，请参阅<a href="https://cwiki.apache.org/confluence/display/KAFKA/KIP-324%3A+Add+method+to+get+metrics%28%29+in+AdminClient">KIP-324</a></li>
<li>Kafka 现在支持<a href="https://cwiki.apache.org/confluence/display/KAFKA/KIP-110%3A+Add+Codec+for+ZStandard+Compression">KIP-110</a>的 Zstandard 压缩。您必须升级经纪商和客户端才能使用它。2.1.0 之前的消费者将无法读取使用 Zstandard 压缩的主题，因此在所有下游消费者升级之前，不应为主题启用它。有关更多详细信息，请参阅 KIP。</li>
</ul>
<h3 id="08x09x0100x0101x0102x0110x10x-11x-200httpskafkaapacheorgdocumentationupgrade_2_0_0">从 0.8.x、0.9.x、0.10.0.x、0.10.1.x、0.10.2.x、0.11.0.x、1.0.x 或 1.1.x 升级到 2.0.0](https://kafka.apache.org/documentation/#upgrade_2_0_0)</h3>
<p>Kafka 2.0.0 引入了有线协议更改。通过遵循下面推荐的滚动升级计划，您可以保证升级期间不会出现停机。不过，请在升级之前查看<a href="https://kafka.apache.org/documentation/#upgrade_200_notable">2.0.0 中的显着变化</a>。</p>
<p><strong>对于滚动升级：</strong></p>
<ol>
<li>
<p>更新所有代理上的 server.properties 并添加以下属性。CURRENT_KAFKA_VERSION 是指您要升级的版本。CURRENT_MESSAGE_FORMAT_VERSION 指当前使用的消息格式版本。如果您之前已覆盖消息格式版本，则应保留其当前值。或者，如果您要从 0.11.0.x 之前的版本升级，则应将 CURRENT_MESSAGE_FORMAT_VERSION 设置为与 CURRENT_KAFKA_VERSION 匹配。</p>
<ul>
<li>inter.broker.protocol.version=CURRENT_KAFKA_VERSION（例如0.8.2、0.9.0、0.10.0、0.10.1、0.10.2、0.11.0、1.0、1.1）。</li>
<li>log.message.format.version=CURRENT_MESSAGE_FORMAT_VERSION（有关此配置的详细信息，请参阅<a href="https://kafka.apache.org/documentation/#upgrade_10_performance_impact">升级后的潜在性能影响。）</a></li>
</ul>
<p>如果您从 0.11.0.x、1.0.x 或 1.1.x 升级并且尚未覆盖消息格式，则只需覆盖代理间协议格式。
*   inter.broker.protocol.version=CURRENT_KAFKA_VERSION（0.11.0、1.0、1.1）。
2.  一次升级一个代理：关闭代理，更新代码，然后重新启动。
3.  整个集群升级后，通过编辑<code>inter.broker.protocol.version</code>并将其设置为 2.0 来提升协议版本。
4.  一一重启broker，新协议版本即可生效。
5.  如果您已按照上述说明覆盖消息格式版本，则需要再进行一次滚动重启才能将其升级到最新版本。一旦所有（或大多数）消费者升级到 0.11.0 或更高版本，将每个代理上的 log.message.format.version 更改为 2.0 并一一重新启动它们。请注意，较旧的 Scala 消费者不支持 0.11 中引入的新消息格式，因此为了避免下转换的性能成本（或利用<a href="https://kafka.apache.org/documentation/#upgrade_11_exactly_once_semantics">恰好一次语义</a>），必须使用较新的 Java 消费者。</p>
</li>
</ol>
<p><strong>附加升级说明：</strong></p>
<ol>
<li>如果您愿意接受停机，您可以简单地关闭所有代理，更新代码并重新启动它们。默认情况下，他们将从新协议开始。</li>
<li>升级代理后，可以随时更改协议版本并重新启动。它不一定是紧随其后。消息格式版本也类似。</li>
<li>如果您在 Kafka Streams 代码中使用 Java8 方法引用，您可能需要更新代码以解决方法歧义。仅热交换 jar 文件可能不起作用。</li>
<li>
<p>在更新集群中的所有代理之前， 不应将 ACL 添加到前缀资源（在<a href="https://cwiki.apache.org/confluence/display/KAFKA/KIP-290%3A+Support+for+Prefixed+ACLs">KIP-290中添加）。</a></p>
<p><strong>注意：如果</strong>集群再次降级，即使在集群完全升级之后，添加到集群的任何前缀 ACL 也将被忽略。</p>
</li>
</ol>
<h4 id="200">2.0.0 中的显着变化</h4>
<ul>
<li><a href="https://cwiki.apache.org/confluence/x/oYtjB">KIP-186</a>将默认偏移量保留时间从 1 天增加到 7 天。这使得在不频繁提交的应用程序中“丢失”偏移量的可能性较小。它还会增加活动的偏移集，因此会增加代理上的内存使用量。请注意，控制台使用者当前默认启用偏移量提交，并且可能是大量偏移量的来源，此更改现在将保留 7 天而不是 1 天。您可以通过将代理配置设置为 1440 来保留现有行为<code>offsets.retention.minutes</code>。</li>
<li>对 Java 7 的支持已取消，Java 8 现在是所需的最低版本。</li>
<li>的默认值<code>ssl.endpoint.identification.algorithm</code>已更改为<code>https</code>，它执行主机名验证（否则可能会发生中间人攻击）。设置<code>ssl.endpoint.identification.algorithm</code>为空字符串以恢复之前的行为。</li>
<li><a href="https://issues.apache.org/jira/browse/KAFKA-5674">KAFKA-5674</a>将最小值的下限间隔扩展<code>max.connections.per.ip</code>到零，因此允许对入站连接进行基于 IP 的过滤。</li>
<li><a href="https://cwiki.apache.org/confluence/display/KAFKA/KIP-272%3A+Add+API+version+tag+to+broker%27s+RequestsPerSec+metric">KIP-272</a> 在指标中添加了 API 版本标签<code>kafka.network:type=RequestMetrics,name=RequestsPerSec,request={Produce|FetchConsumer|FetchFollower|...}</code>。这个指标现在变成了<code>kafka.network:type=RequestMetrics,name=RequestsPerSec,request={Produce|FetchConsumer|FetchFollower|...},version={0|1|2|3|...}</code>。这将影响不自动聚合的 JMX 监控工具。要获取特定请求类型的总计数，需要更新该工具以跨不同版本进行聚合。</li>
<li><a href="https://cwiki.apache.org/confluence/x/uaBzB">KIP-225</a>更改了指标“records.lag”以使用主题和分区的标签。名称格式为“{topic}-{partition}.records-lag”的原始版本已被删除。</li>
<li>自 0.11.0.0 起已弃用的 Scala 消费者已被删除。自 0.10.0.0 以来，Java 消费者一直是推荐的选项。请注意，即使代理升级到 2.0.0，1.1.0（及更早版本）中的 Scala 消费者也将继续工作。</li>
<li>自 0.10.0.0 起已弃用的 Scala 生产者已被删除。从 0.9.0.0 开始，Java 生产者一直是推荐选项。请注意，Java 生产者中默认分区器的行为与 Scala 生产者中默认分区器的行为不同。迁移的用户应考虑配置保留以前行为的自定义分区程序。请注意，即使代理升级到 2.0.0，1.1.0（及更早版本）中的 Scala 生产者也将继续工作。</li>
<li>MirrorMaker 和 ConsoleConsumer 不再支持 Scala 消费者，它们始终使用 Java 消费者。</li>
<li>ConsoleProducer 不再支持 Scala 生产者，它始终使用 Java 生产者。</li>
<li>许多依赖 Scala 客户端的已弃用工具已被删除：ReplayLogProducer、SimpleConsumerPerformance、SimpleConsumerShell、ExportZkOffsets、ImportZkOffsets、UpdateOffsetsInZK、VerifyConsumerRebalance。</li>
<li>已弃用的 kafka.tools.ProducerPerformance 已被删除，请使用 org.apache.kafka.tools.ProducerPerformance。</li>
<li>添加了新的 Kafka Streams 配置参数<code>upgrade.from</code>，允许从旧版本滚动反弹升级。</li>
<li><a href="https://cwiki.apache.org/confluence/x/DVyHB">KIP-284</a>通过将默认值设置为 来更改 Kafka Streams 重新分区主题的保留时间<code>Long.MAX_VALUE</code>。</li>
<li>更新了<code>ProcessorStateManager</code>Kafka Streams 中的 API，用于将状态存储注册到处理器拓扑。欲了解更多详细信息，请阅读 Streams<a href="https://kafka.apache.org/35/documentation/streams/upgrade-guide#streams_api_changes_200">升级指南</a>。</li>
<li>在早期版本中，Connect 的工作线程配置需要<code>internal.key.converter</code>和<code>internal.value.converter</code>属性。<a href="https://cwiki.apache.org/confluence/x/AZQ7B">在 2.0 中，不再需要</a>这些，并且默认为 JSON 转换器。您可以安全地从 Connect 独立和分布式工作线程配置中删除这些属性：<br />
<code>internal.key.converter=org.apache.kafka.connect.json.JsonConverter</code> <code>internal.key.converter.schemas.enable=false</code> <code>internal.value.converter=org.apache.kafka.connect.json.JsonConverter</code> <code>internal.value.converter.schemas.enable=false</code></li>
<li><a href="https://cwiki.apache.org/confluence/x/5kiHB">KIP-266</a>添加了一个新的消费者配置<code>default.api.timeout.ms</code> ，以指定用于可能阻塞的 API 的默认超时<code>KafkaConsumer</code>。KIP 还为此类阻塞 API 添加了重载，以支持为每个 API 指定特定的超时，而不是使用<code>default.api.timeout.ms</code>. 特别是，<code>poll(Duration)</code>添加了一个新的 API，该 API 不会阻止动态分区分配。旧的<code>poll(long)</code>API 已被弃用，并将在未来版本中删除。<code>KafkaConsumer</code>还为其他方法添加了重载，例如<code>partitionsFor</code>, <code>listTopics</code>, <code>offsetsForTimes</code>, <code>beginningOffsets</code>,<code>endOffsets</code>以及<code>close</code>接受<code>Duration</code>.</li>
<li>另外，作为 KIP-266 的一部分，默认值<code>request.timeout.ms</code>已更改为 30 秒。考虑到重新平衡所需的最长时间，之前的值略高于 5 分钟。<code>max.poll.interval.ms</code>现在，我们将重新平衡中的 JoinGroup 请求视为特殊情况，并使用从请求超时派生的值 。所有其他请求类型使用以下定义的超时<code>request.timeout.ms</code></li>
<li>内部方法<code>kafka.admin.AdminClient.deleteRecordsBefore</code>已被删除。鼓励用户迁移到<code>org.apache.kafka.clients.admin.AdminClient.deleteRecords</code>.</li>
<li>AclCommand 工具<code>--producer</code>便利选项在给定主题上使用<a href="https://cwiki.apache.org/confluence/display/KAFKA/KIP-277+-+Fine+Grained+ACL+for+CreateTopics+API">KIP-277更细粒度的 ACL。</a></li>
<li><a href="https://cwiki.apache.org/confluence/display/KAFKA/KIP-176%3A+Remove+deprecated+new-consumer+option+for+tools">KIP-176</a>删除了<code>--new-consumer</code>所有基于消费者的工具的选项。此选项是多余的，因为如果定义了 --bootstrap-server，则会自动使用新的使用者。</li>
<li><a href="https://cwiki.apache.org/confluence/display/KAFKA/KIP-290%3A+Support+for+Prefixed+ACLs">KIP-290</a>添加了在前缀资源上定义 ACL 的能力，例如以“foo”开头的任何主题。</li>
<li>
<p><a href="https://cwiki.apache.org/confluence/display/KAFKA/KIP-283%3A+Efficient+Memory+Usage+for+Down-Conversion">KIP-283</a>改进了 Kafka 代理上的消息下转换处理，这通常是一项内存密集型操作。KIP 添加了一种机制，通过一次向下转换分区数据块，操作会减少内存密集度，这有助于设定内存消耗的上限。通过这一改进，协议行为发生了变化 <code>FetchResponse</code>，代理可以在响应结束时发送带有无效偏移量的超大消息批次。消费者客户端必须忽略此类过大的消息，就像<code>KafkaConsumer</code>.</p>
<p>KIP-283还添加了新的主题和代理配置<code>message.downconversion.enable</code>，<code>log.message.downconversion.enable</code>分别控制是否启用下转换。禁用后，代理不会执行任何下转换，而是<code>UNSUPPORTED_VERSION</code> 向客户端发送错误。</p>
</li>
<li>
<p>在启动代理之前，可以使用 kafka-configs.sh 将动态代理配置选项存储在 ZooKeeper 中。此选项可用于避免在 server.properties 中存储明文密码，因为所有密码配置都可能以加密方式存储在 ZooKeeper 中。</p>
</li>
<li>如果连接尝试失败，ZooKeeper 主机现在会重新解析。但是，如果您的 ZooKeeper 主机名解析为多个地址，并且其中一些地址无法访问，那么您可能需要增加连接超时 <code>zookeeper.connection.timeout.ms</code>。</li>
</ul>
<h4 id="_13">新协议版本</h4>
<ul>
<li><a href="https://cwiki.apache.org/confluence/display/KAFKA/KIP-279%3A+Fix+log+divergence+between+leader+and+follower+after+fast+leader+fail+over">KIP-279</a>：OffsetsForLeaderEpochResponse v1 引入了分区级<code>leader_epoch</code>字段。</li>
<li><a href="https://cwiki.apache.org/confluence/display/KAFKA/KIP-219+-+Improve+quota+communication">KIP-219</a>：提高因配额违规而受到限制的非集群操作请求和响应的协议版本。</li>
<li><a href="https://cwiki.apache.org/confluence/display/KAFKA/KIP-290%3A+Support+for+Prefixed+ACLs">KIP-290</a>：提高 ACL 创建、描述和删除请求和响应的协议版本。</li>
</ul>
<h4 id="11-kafka-streams">升级 1.1 Kafka Streams 应用程序</h4>
<ul>
<li>将 Streams 应用程序从 1.1 升级到 2.0 不需要代理升级。Kafka Streams 2.0 应用程序可以连接到 2.0、1.1、1.0、0.11.0、0.10.2 和 0.10.1 代理（但无法连接到 0.10.0 代理）。</li>
<li>请注意，在 2.0 中，我们删除了 1.0 之前已弃用的公共 API；利用这些已弃用的 API 的用户需要相应地更改代码。有关更多详细信息，请参阅<a href="https://kafka.apache.org/35/documentation/streams/upgrade-guide#streams_api_changes_200">2.0.0 中的 Streams API 更改。</a></li>
</ul>
<h3 id="08x09x0100x0101x0102x0110x-10x-11x">从 0.8.x、0.9.x、0.10.0.x、0.10.1.x、0.10.2.x、0.11.0.x 或 1.0.x 升级到 1.1.x</h3>
<p>Kafka 1.1.0 引入了有线协议更改。通过遵循下面推荐的滚动升级计划，您可以保证升级期间不会出现停机。不过，请在升级之前查看<a href="https://kafka.apache.org/documentation/#upgrade_110_notable">1.1.0 中的显着变化</a>。</p>
<p><strong>对于滚动升级：</strong></p>
<ol>
<li>
<p>更新所有代理上的 server.properties 并添加以下属性。CURRENT_KAFKA_VERSION 是指您要升级的版本。CURRENT_MESSAGE_FORMAT_VERSION 指当前使用的消息格式版本。如果您之前已覆盖消息格式版本，则应保留其当前值。或者，如果您要从 0.11.0.x 之前的版本升级，则应将 CURRENT_MESSAGE_FORMAT_VERSION 设置为与 CURRENT_KAFKA_VERSION 匹配。</p>
<ul>
<li>inter.broker.protocol.version=CURRENT_KAFKA_VERSION（例如0.8.2、0.9.0、0.10.0、0.10.1、0.10.2、0.11.0、1.0）。</li>
<li>log.message.format.version=CURRENT_MESSAGE_FORMAT_VERSION（有关此配置的详细信息，请参阅<a href="https://kafka.apache.org/documentation/#upgrade_10_performance_impact">升级后的潜在性能影响。）</a></li>
</ul>
<p>如果您从 0.11.0.x 或 1.0.x 升级并且尚未覆盖消息格式，则只需覆盖代理间协议格式。
*   inter.broker.protocol.version=CURRENT_KAFKA_VERSION（0.11.0 或 1.0）。
2.  一次升级一个代理：关闭代理，更新代码，然后重新启动。
3.  整个集群升级后，通过编辑<code>inter.broker.protocol.version</code>并将其设置为 1.1 来提升协议版本。
4.  一一重启broker，新协议版本即可生效。
5.  如果您已按照上述说明覆盖消息格式版本，则需要再进行一次滚动重启才能将其升级到最新版本。一旦所有（或大多数）消费者升级到 0.11.0 或更高版本，将每个代理上的 log.message.format.version 更改为 1.1 并一一重新启动它们。请注意，较旧的 Scala 消费者不支持 0.11 中引入的新消息格式，因此为了避免下转换的性能成本（或利用<a href="https://kafka.apache.org/documentation/#upgrade_11_exactly_once_semantics">恰好一次语义</a>），必须使用较新的 Java 消费者。</p>
</li>
</ol>
<p><strong>附加升级说明：</strong></p>
<ol>
<li>如果您愿意接受停机，您可以简单地关闭所有代理，更新代码并重新启动它们。默认情况下，他们将从新协议开始。</li>
<li>升级代理后，可以随时更改协议版本并重新启动。它不一定是紧随其后。消息格式版本也类似。</li>
<li>如果您在 Kafka Streams 代码中使用 Java8 方法引用，您可能需要更新代码以解决方法歧义。仅热交换 jar 文件可能不起作用。</li>
</ol>
<h4 id="111">1.1.1 中的显着变化</h4>
<ul>
<li>添加了新的 Kafka Streams 配置参数<code>upgrade.from</code>，允许从版本 0.10.0.x 滚动弹跳升级</li>
<li>有关此新配置的详细信息， 请参阅<a href="https://kafka.apache.org/35/documentation/streams/upgrade-guide.html"><strong>Kafka Streams 升级指南。</strong></a></li>
</ul>
<h4 id="110">1.1.0 中的显着变化</h4>
<ul>
<li>Maven 中的 kafka 工件不再依赖 log4j 或 slf4j-log4j12。与 kafka-clients 工件类似，用户现在可以通过包含适当的 slf4j 模块（slf4j-log4j12、logback 等）来选择日志记录后端。发布 tarball 仍然包含 log4j 和 slf4j-log4j12。</li>
<li><a href="https://cwiki.apache.org/confluence/x/uaBzB">KIP-225</a>更改了指标“records.lag”以使用主题和分区的标签。名称格式为“{topic}-{partition}.records-lag”的原始版本已弃用，并将在 2.0.0 中删除。</li>
<li>Kafka Streams 对于代理通信错误更加稳健。Kafka Streams 不会因致命异常而停止 Kafka Streams 客户端，而是尝试自我修复并重新连接到集群。使用新版本，<code>AdminClient</code>您可以更好地控制 Kafka Streams 重试的频率，并可以<a href="https://kafka.apache.org/35/documentation/streams/developer-guide/config-streams">配置</a> 细粒度的超时（而不是像旧版本中那样硬编码重试）。</li>
<li>Kafka Streams 重新平衡时间进一步减少，使 Kafka Streams 的响应速度更快。</li>
<li>Kafka Connect 现在支持接收器和源连接器中的消息标头，并通过简单的消息转换来操作它们。必须更改连接器才能显式使用它们。引入了一个新功能<code>HeaderConverter</code>来控制标头的序列化（反序列化）方式，并且默认情况下使用新的“SimpleHeaderConverter”来使用值的字符串表示形式。</li>
<li>如果由于解码器等任何其他选项而显式或隐式启用打印数据日志，kafka.tools.DumpLogSegments 现在会自动设置深度迭代选项。</li>
</ul>
<h4 id="_14">新协议版本</h4>
<ul>
<li><a href="https://cwiki.apache.org/confluence/display/KAFKA/KIP-226+-+Dynamic+Broker+Configuration">KIP-226</a>引入了DescribeConfigs 请求/响应 v1。</li>
<li><a href="https://cwiki.apache.org/confluence/display/KAFKA/KIP-227%3A+Introduce+Incremental+FetchRequests+to+Increase+Partition+Scalability">KIP-227</a>引入了 Fetch Request/Response v7。</li>
</ul>
<h4 id="10-kafka-streams">升级 1.0 Kafka Streams 应用程序</h4>
<ul>
<li>将 Streams 应用程序从 1.0 升级到 1.1 不需要代理升级。Kafka Streams 1.1 应用程序可以连接到 1.0、0.11.0、0.10.2 和 0.10.1 代理（但无法连接到 0.10.0 代理）。</li>
<li>有关更多详细信息，请参阅<a href="https://kafka.apache.org/35/documentation/streams/upgrade-guide#streams_api_changes_110">1.1.0 中的 Streams API 更改。</a></li>
</ul>
<h3 id="08x09x0100x0101x0102x-0110x-100">从 0.8.x、0.9.x、0.10.0.x、0.10.1.x、0.10.2.x 或 0.11.0.x 升级到 1.0.0</h3>
<p>Kafka 1.0.0 引入了有线协议更改。通过遵循下面推荐的滚动升级计划，您可以保证升级期间不会出现停机。不过，请在升级之前查看<a href="https://kafka.apache.org/documentation/#upgrade_100_notable">1.0.0 中的显着变化</a>。</p>
<p><strong>对于滚动升级：</strong></p>
<ol>
<li>
<p>更新所有代理上的 server.properties 并添加以下属性。CURRENT_KAFKA_VERSION 是指您要升级的版本。CURRENT_MESSAGE_FORMAT_VERSION 指当前使用的消息格式版本。如果您之前已覆盖消息格式版本，则应保留其当前值。或者，如果您要从 0.11.0.x 之前的版本升级，则应将 CURRENT_MESSAGE_FORMAT_VERSION 设置为与 CURRENT_KAFKA_VERSION 匹配。</p>
<ul>
<li>inter.broker.protocol.version=CURRENT_KAFKA_VERSION（例如0.8.2、0.9.0、0.10.0、0.10.1、0.10.2、0.11.0）。</li>
<li>log.message.format.version=CURRENT_MESSAGE_FORMAT_VERSION（有关此配置的详细信息，请参阅<a href="https://kafka.apache.org/documentation/#upgrade_10_performance_impact">升级后的潜在性能影响。）</a></li>
</ul>
<p>如果您从 0.11.0.x 升级并且未覆盖消息格式，则必须将消息格式版本和代理间协议版本设置为 0.11.0。
*   inter.broker.protocol.version=0.11.0
*   log.message.format.version=0.11.0
2.  一次升级一个代理：关闭代理，更新代码，然后重新启动。
3.  整个集群升级后，通过编辑<code>inter.broker.protocol.version</code>并将其设置为 1.0 来提升协议版本。
4.  一一重启broker，新协议版本即可生效。
5.  如果您已按照上述说明覆盖消息格式版本，则需要再进行一次滚动重启才能将其升级到最新版本。一旦所有（或大多数）消费者升级到 0.11.0 或更高版本，将每个代理上的 log.message.format.version 更改为 1.0 并一一重新启动它们。如果您从 0.11.0 升级并且 log.message.format.version 设置为 0.11.0，则可以更新配置并跳过滚动重启。请注意，较旧的 Scala 消费者不支持 0.11 中引入的新消息格式，因此为了避免下转换的性能成本（或利用<a href="https://kafka.apache.org/documentation/#upgrade_11_exactly_once_semantics">恰好一次语义</a>），必须使用较新的 Java 消费者。</p>
</li>
</ol>
<p><strong>附加升级说明：</strong></p>
<ol>
<li>如果您愿意接受停机，您可以简单地关闭所有代理，更新代码并重新启动它们。默认情况下，他们将从新协议开始。</li>
<li>升级代理后，可以随时更改协议版本并重新启动。它不一定是紧随其后。消息格式版本也类似。</li>
</ol>
<h4 id="102">1.0.2 中的显着变化</h4>
<ul>
<li>添加了新的 Kafka Streams 配置参数<code>upgrade.from</code>，允许从版本 0.10.0.x 滚动弹跳升级</li>
<li>有关此新配置的详细信息， 请参阅<a href="https://kafka.apache.org/35/documentation/streams/upgrade-guide.html"><strong>Kafka Streams 升级指南。</strong></a></li>
</ul>
<h4 id="101">1.0.1 中的显着变化</h4>
<ul>
<li>恢复了 AdminClient 的选项类（例如 CreateTopicsOptions、DeleteTopicsOptions 等）与 0.11.0.x 的二进制兼容性。二进制（但不是源代码）兼容性在 1.0.0 中被无意中破坏。</li>
</ul>
<h4 id="100">1.0.0 中的显着变化</h4>
<ul>
<li>现在默认启用主题删除，因为该功能现已稳定。希望保留以前行为的用户应将代理配置设置<code>delete.topic.enable</code>为<code>false</code>。请记住，主题删除会删除数据，并且该操作是不可逆的（即不存在“取消删除”操作）</li>
<li>对于支持时间戳搜索的主题，如果找不到分区的偏移量，则该分区现在包含在搜索结果中，且偏移量值为空。以前，分区不包含在地图中。进行此更改是为了使搜索行为与不支持时间戳搜索的主题的情况一致。</li>
<li>如果<code>inter.broker.protocol.version</code>是 1.0 或更高版本，即使存在脱机日志目录，代理现在也将保持在线状态以在实时日志目录上提供副本。由于硬件故障引起的IOException，日志目录可能会离线。用户需要监控每个broker的指标<code>offlineLogDirectoryCount</code>来检查是否存在离线日志目录。</li>
<li>添加了 KafkaStorageException，这是一个可重试的异常。如果客户端的FetchRequest或ProducerRequest的版本不支持KafkaStorageException，则响应中的KafkaStorageException将转换为NotLeaderForPartitionException。</li>
<li>默认 JVM 设置中的 -XX:+DisableExplicitGC 已替换为 -XX:+ExplicitGCInvokesConcurrent。在某些情况下，这有助于避免在通过直接缓冲区分配本机内存期间出现内存不足异常。</li>
<li><code>handleError</code>已从包中以下已弃用的类中删除了重写的方法实现<code>kafka.api</code>：<code>FetchRequest</code>、<code>GroupCoordinatorRequest</code>、<code>OffsetCommitRequest</code>、 <code>OffsetFetchRequest</code>、<code>OffsetRequest</code>、<code>ProducerRequest</code>和<code>TopicMetadataRequest</code>。这仅适用于代理，但已不再使用且实现也未得到维护。为了二进制兼容性，保留了存根实现。</li>
<li>Java 客户端和工具现在接受任何字符串作为客户端 ID。</li>
<li>已弃用的工具<code>kafka-consumer-offset-checker.sh</code>已被删除。用于<code>kafka-consumer-groups.sh</code>获取消费者组详细信息。</li>
<li>SimpleAclAuthorizer 现在默认将访问拒绝记录到授权者日志中。</li>
<li>身份验证失败现在作为 的子类之一报告给客户端<code>AuthenticationException</code>。如果客户端连接身份验证失败，则不会执行重试。</li>
<li>自定义<code>SaslServer</code>实现可能会<code>SaslAuthenticationException</code>抛出错误消息以返回给客户端，指示身份验证失败的原因。实施者应注意不要在异常消息中包含任何安全关键信息，这些信息不应泄露给未经身份验证的客户端。</li>
<li>向 JMX 注册以提供版本和提交 ID 的mbean<code>app-info</code>将被弃用，并替换为提供这些属性的指标。</li>
<li>Kafka 指标现在可能包含非数字值。<code>org.apache.kafka.common.Metric#value()</code>已被弃用，并将<code>0.0</code>在这种情况下返回，以最大限度地减少破坏读取每个客户端指标值的用户的可能性（通过实现<code>MetricsReporter</code>或调用该<code>metrics()</code>方法）。 <code>org.apache.kafka.common.Metric#metricValue()</code>可用于检索数字和非数字度量值。</li>
<li>现在，每个 Kafka 速率指标都有一个相应的累积计数指标，并带有后缀<code>-total</code> 以简化下游处理。例如，<code>records-consumed-rate</code>有一个名为 的相应指标<code>records-consumed-total</code>。</li>
<li><code>kafka_mx4jenable</code>仅当系统属性设置为时，才会启用 Mx4j <code>true</code>。由于逻辑反转错误，它以前默认启用，如果<code>kafka_mx4jenable</code>设置为则禁用<code>true</code>。</li>
<li>客户端 jar 中的包<code>org.apache.kafka.common.security.auth</code>已公开并添加到 javadocs 中。以前位于此包中的内部类已移至其他地方。</li>
<li>当使用授权者并且用户没有主题所需的权限时，代理将向请求返回 TOPIC_AUTHORIZATION_FAILED 错误，无论代理上是否存在主题。如果用户具有所需的权限并且主题不存在，则将返回 UNKNOWN_TOPIC_OR_PARTITION 错误代码。</li>
<li>config/consumer.properties 文件已更新以使用新的消费者配置属性。</li>
</ul>
<h4 id="_15">新协议版本</h4>
<ul>
<li><a href="https://cwiki.apache.org/confluence/display/KAFKA/KIP-112%3A+Handle+disk+failure+for+JBOD">KIP-112</a>：LeaderAndIsrRequest v1 引入了分区级<code>is_new</code>字段。</li>
<li><a href="https://cwiki.apache.org/confluence/display/KAFKA/KIP-112%3A+Handle+disk+failure+for+JBOD">KIP-112</a>：UpdateMetadataRequest v4 引入了分区级<code>offline_replicas</code>字段。</li>
<li><a href="https://cwiki.apache.org/confluence/display/KAFKA/KIP-112%3A+Handle+disk+failure+for+JBOD">KIP-112</a>：MetadataResponse v5 引入了分区级<code>offline_replicas</code>字段。</li>
<li><a href="https://cwiki.apache.org/confluence/display/KAFKA/KIP-112%3A+Handle+disk+failure+for+JBOD">KIP-112</a>：ProduceResponse v4 引入了 KafkaStorageException 的错误代码。</li>
<li><a href="https://cwiki.apache.org/confluence/display/KAFKA/KIP-112%3A+Handle+disk+failure+for+JBOD">KIP-112</a>：FetchResponse v6 引入了 KafkaStorageException 的错误代码。</li>
<li><a href="https://cwiki.apache.org/confluence/display/KAFKA/KIP-152+-+Improve+diagnostics+for+SASL+authentication+failures">KIP-152</a>：添加了 SaslAuthenticate 请求以启用身份验证失败报告。如果 SaslHandshake 请求版本大于 0，则将使用此请求。</li>
</ul>
<h4 id="0110-kafka-streams">升级 0.11.0 Kafka Streams 应用程序</h4>
<ul>
<li>将 Streams 应用程序从 0.11.0 升级到 1.0 不需要代理升级。Kafka Streams 1.0 应用程序可以连接到 0.11.0、0.10.2 和 0.10.1 代理（但无法连接到 0.10.0 代理）。但是，Kafka Streams 1.0 需要 0.10 消息格式或更新版本，并且不适用于较旧的消息格式。</li>
<li>如果您正在监视流指标，则需要对报告和监视代码中的指标名称进行一些更改，因为指标传感器层次结构已更改。</li>
<li>有一些公共 API，包括<code>ProcessorContext#schedule()</code>、<code>Processor#punctuate()</code>和<code>KStreamBuilder</code>，<code>TopologyBuilder</code>已被新 API 弃用。我们建议您在升级时进行相应的代码更改，这些更改应该非常小，因为新的 API 看起来非常相似。</li>
<li>有关更多详细信息，请参阅<a href="https://kafka.apache.org/35/documentation/streams/upgrade-guide#streams_api_changes_100">1.0.0 中的 Streams API 更改。</a></li>
</ul>
<h4 id="0102-kafka-streams">升级 0.10.2 Kafka Streams 应用程序</h4>
<ul>
<li>将 Streams 应用程序从 0.10.2 升级到 1.0 不需要代理升级。Kafka Streams 1.0 应用程序可以连接到 1.0、0.11.0、0.10.2 和 0.10.1 代理（但无法连接到 0.10.0 代理）。</li>
<li>如果您正在监视流指标，则需要对报告和监视代码中的指标名称进行一些更改，因为指标传感器层次结构已更改。</li>
<li>有一些公共 API，包括<code>ProcessorContext#schedule()</code>、<code>Processor#punctuate()</code>和<code>KStreamBuilder</code>，<code>TopologyBuilder</code>已被新 API 弃用。我们建议您在升级时进行相应的代码更改，这些更改应该非常小，因为新的 API 看起来非常相似。</li>
<li>如果您在配置中指定了customized <code>key.serde</code>,<code>value.serde</code>和<code>timestamp.extractor</code>，建议使用它们替换的配置参数，因为这些配置已被弃用。</li>
<li>有关更多详细信息，请参阅<a href="https://kafka.apache.org/35/documentation/streams/upgrade-guide#streams_api_changes_0110">0.11.0 中的 Streams API 更改。</a></li>
</ul>
<h4 id="0101-kafka-streams">升级 0.10.1 Kafka Streams 应用程序</h4>
<ul>
<li>将 Streams 应用程序从 0.10.1 升级到 1.0 不需要代理升级。Kafka Streams 1.0 应用程序可以连接到 1.0、0.11.0、0.10.2 和 0.10.1 代理（但无法连接到 0.10.0 代理）。</li>
<li>您需要重新编译您的代码。仅交换 Kafka Streams 库 jar 文件是行不通的，并且会破坏您的应用程序。</li>
<li>如果您正在监视流指标，则需要对报告和监视代码中的指标名称进行一些更改，因为指标传感器层次结构已更改。</li>
<li>有一些公共 API，包括<code>ProcessorContext#schedule()</code>、<code>Processor#punctuate()</code>和<code>KStreamBuilder</code>，<code>TopologyBuilder</code>已被新 API 弃用。我们建议您在升级时进行相应的代码更改，这些更改应该非常小，因为新的 API 看起来非常相似。</li>
<li>如果您在配置中指定了customized <code>key.serde</code>,<code>value.serde</code>和<code>timestamp.extractor</code>，建议使用它们替换的配置参数，因为这些配置已被弃用。</li>
<li>如果您使用自定义（即用户实现的）时间戳提取器，您将需要更新此代码，因为接口<code>TimestampExtractor</code>已更改。</li>
<li>如果您注册自定义指标，则需要更新此代码，因为<code>StreamsMetric</code>界面已更改。</li>
<li>有关更多详细信息，请参阅<a href="https://kafka.apache.org/35/documentation/streams/upgrade-guide#streams_api_changes_100">1.0.0 中的 Streams API 更改</a>、 <a href="https://kafka.apache.org/35/documentation/streams/upgrade-guide#streams_api_changes_0110">0.11.0 中的 Streams API 更改</a>和 <a href="https://kafka.apache.org/35/documentation/streams/upgrade-guide#streams_api_changes_0102">0.10.2 中的 Streams API 更改。</a></li>
</ul>
<h4 id="0100-kafka-streams">升级 0.10.0 Kafka Streams 应用程序</h4>
<ul>
<li>将 Streams 应用程序从 0.10.0 升级到 1.0 确实需要<a href="https://kafka.apache.org/documentation/#upgrade_10_1">代理升级</a>，因为 Kafka Streams 1.0 应用程序只能连接到 0.1、0.11.0、0.10.2 或 0.10.1 代理。</li>
<li>有一些 API 更改不向后兼容（请参阅<a href="https://kafka.apache.org/35/documentation/streams/upgrade-guide#streams_api_changes_100">1.0.0 中的 Streams API 更改</a>、 <a href="https://kafka.apache.org/35/documentation/streams#streams_api_changes_0110">0.11.0 中的 Streams API 更改</a>、 <a href="https://kafka.apache.org/35/documentation/streams#streams_api_changes_0102">0.10.2 中的 Streams API 更改</a>和 <a href="https://kafka.apache.org/35/documentation/streams#streams_api_changes_0101">0.10.1 中的 Streams API 更改</a>了解更多详细信息）。因此，您需要更新并重新编译代码。仅交换 Kafka Streams 库 jar 文件是行不通的，并且会破坏您的应用程序。</li>
<li>从 0.10.0.x 升级到 1.0.2 需要两次滚动反弹，并<code>upgrade.from="0.10.0"</code>为第一个升级阶段设置配置（参见<a href="https://cwiki.apache.org/confluence/display/KAFKA/KIP-268%3A+Simplify+Kafka+Streams+Rebalance+Metadata+Upgrade">KIP-268</a>）。作为替代方案，也可以进行离线升级。<ul>
<li>准备应用程序实例以进行滚动反弹，并确保将配置<code>upgrade.from</code>设置<code>"0.10.0"</code>为新版本 0.11.0.3</li>
<li>将应用程序的每个实例退回一次</li>
<li>为新部署的 1.0.2 应用程序实例做好第二轮滚动跳出的准备；确保删除 config 的值<code>upgrade.from</code></li>
<li>再次弹跳应用程序的每个实例以完成升级</li>
</ul>
</li>
<li>从0.10.0.x升级到1.0.0或1.0.1需要离线升级（不支持滚动弹跳升级）<ul>
<li>停止所有旧的（0.10.0.x）应用程序实例</li>
<li>更新您的代码并将旧代码和 jar 文件替换为新代码和新 jar 文件</li>
<li>重新启动所有新的（1.0.0 或 1.0.1）应用程序实例</li>
</ul>
</li>
</ul>
<h3 id="08x09x0100x0101x-0102x-01100">从 0.8.x、0.9.x、0.10.0.x、0.10.1.x 或 0.10.2.x 升级到 0.11.0.0</h3>
<p>Kafka 0.11.0.0 引入了新的消息格式版本以及有线协议更改。通过遵循下面推荐的滚动升级计划，您可以保证升级期间不会出现停机。但是，请在升级之前查看<a href="https://kafka.apache.org/documentation/#upgrade_1100_notable">0.11.0.0 中的显着变化</a>。</p>
<p>从版本 0.10.2 开始，Java 客户端（生产者和消费者）已经获得了与旧代理进行通信的能力。版本 0.11.0 客户端可以与版本 0.10.0 或更高版本的代理进行通信。但是，如果您的代理低于 0.10.0，则必须在升级客户端之前升级 Kafka 集群中的所有代理。版本 0.11.0 代理支持 0.8.x 及更高版本的客户端。</p>
<p><strong>对于滚动升级：</strong></p>
<ol>
<li>更新所有代理上的 server.properties 并添加以下属性。CURRENT_KAFKA_VERSION 是指您要升级的版本。CURRENT_MESSAGE_FORMAT_VERSION 指当前使用的当前消息格式版本。如果您之前没有覆盖消息格式，则应将 CURRENT_MESSAGE_FORMAT_VERSION 设置为与 CURRENT_KAFKA_VERSION 匹配。<ul>
<li>inter.broker.protocol.version=CURRENT_KAFKA_VERSION（例如0.8.2、0.9.0、0.10.0、0.10.1或0.10.2）。</li>
<li>log.message.format.version=CURRENT_MESSAGE_FORMAT_VERSION（有关此配置的详细信息，请参阅<a href="https://kafka.apache.org/documentation/#upgrade_10_performance_impact">升级后的潜在性能影响。）</a></li>
</ul>
</li>
<li>一次升级一个代理：关闭代理，更新代码，然后重新启动。</li>
<li>整个集群升级后，通过编辑并将<code>inter.broker.protocol.version</code>其设置为 0.11.0 来提升协议版本，但暂时不要更改<code>log.message.format.version</code>。</li>
<li>一一重启broker，新协议版本即可生效。</li>
<li>一旦所有（或大多数）消费者升级到 0.11.0 或更高版本，然后在每个代理上将 log.message.format.version 更改为 0.11.0 并一一重新启动它们。请注意，旧的 Scala 消费者不支持新的消息格式，因此为了避免下转换的性能成本（或利用<a href="https://kafka.apache.org/documentation/#upgrade_11_exactly_once_semantics">恰好一次语义</a>），必须使用新的 Java 消费者。</li>
</ol>
<p><strong>附加升级说明：</strong></p>
<ol>
<li>如果您愿意接受停机，您可以简单地关闭所有代理，更新代码并重新启动它们。默认情况下，他们将从新协议开始。</li>
<li>升级代理后，可以随时更改协议版本并重新启动。它不一定是紧随其后。消息格式版本也类似。</li>
<li><code>bin/kafka-topics.sh</code>在更新全局设置之前，还可以使用主题管理工具 () 在各个主题上启用 0.11.0 消息格式<code>log.message.format.version</code>。</li>
<li>如果您要从 0.10.0 之前的版本升级，则无需在切换到 0.11.0 之前先将消息格式更新到 0.10.0。</li>
</ol>
<h4 id="0102-kafka-streams_1">升级 0.10.2 Kafka Streams 应用程序</h4>
<ul>
<li>将 Streams 应用程序从 0.10.2 升级到 0.11.0 不需要代理升级。Kafka Streams 0.11.0 应用程序可以连接到 0.11.0、0.10.2 和 0.10.1 代理（但无法连接到 0.10.0 代理）。</li>
<li>如果您在配置中指定了customized <code>key.serde</code>,<code>value.serde</code>和<code>timestamp.extractor</code>，建议使用它们替换的配置参数，因为这些配置已被弃用。</li>
<li>有关更多详细信息，请参阅<a href="https://kafka.apache.org/35/documentation/streams/upgrade-guide#streams_api_changes_0110">0.11.0 中的 Streams API 更改。</a></li>
</ul>
<h4 id="0101-kafka-streams_1">升级 0.10.1 Kafka Streams 应用程序</h4>
<ul>
<li>将 Streams 应用程序从 0.10.1 升级到 0.11.0 不需要代理升级。Kafka Streams 0.11.0 应用程序可以连接到 0.11.0、0.10.2 和 0.10.1 代理（但无法连接到 0.10.0 代理）。</li>
<li>您需要重新编译您的代码。仅交换 Kafka Streams 库 jar 文件是行不通的，并且会破坏您的应用程序。</li>
<li>如果您在配置中指定了customized <code>key.serde</code>,<code>value.serde</code>和<code>timestamp.extractor</code>，建议使用它们替换的配置参数，因为这些配置已被弃用。</li>
<li>如果您使用自定义（即用户实现的）时间戳提取器，您将需要更新此代码，因为接口<code>TimestampExtractor</code>已更改。</li>
<li>如果您注册自定义指标，则需要更新此代码，因为<code>StreamsMetric</code>界面已更改。</li>
<li>有关更多详细信息，请参阅<a href="https://kafka.apache.org/35/documentation/streams/upgrade-guide#streams_api_changes_0110">0.11.0 中的 Streams API 更改</a>和 <a href="https://kafka.apache.org/35/documentation/streams/upgrade-guide#streams_api_changes_0102">0.10.2 中的 Streams API 更改。</a></li>
</ul>
<h4 id="0100-kafka-streams_1">升级 0.10.0 Kafka Streams 应用程序</h4>
<ul>
<li>将 Streams 应用程序从 0.10.0 升级到 0.11.0 确实需要<a href="https://kafka.apache.org/documentation/#upgrade_10_1">代理升级</a>，因为 Kafka Streams 0.11.0 应用程序只能连接到 0.11.0、0.10.2 或 0.10.1 代理。</li>
<li>有一些 API 更改不向后兼容（请参阅<a href="https://kafka.apache.org/35/documentation/streams#streams_api_changes_0110">0.11.0 中的 Streams API 更改</a>、 <a href="https://kafka.apache.org/35/documentation/streams#streams_api_changes_0102">0.10.2 中的 Streams API 更改</a>和 <a href="https://kafka.apache.org/35/documentation/streams#streams_api_changes_0101">0.10.1 中的 Streams API 更改</a>以了解更多详细信息）。因此，您需要更新并重新编译代码。仅交换 Kafka Streams 库 jar 文件是行不通的，并且会破坏您的应用程序。</li>
<li>从 0.10.0.x 升级到 0.11.0.3 需要两次滚动反弹，并<code>upgrade.from="0.10.0"</code>为第一个升级阶段设置配置（参见<a href="https://cwiki.apache.org/confluence/display/KAFKA/KIP-268%3A+Simplify+Kafka+Streams+Rebalance+Metadata+Upgrade">KIP-268</a>）。作为替代方案，也可以进行离线升级。<ul>
<li>准备应用程序实例以进行滚动反弹，并确保将配置<code>upgrade.from</code>设置<code>"0.10.0"</code>为新版本 0.11.0.3</li>
<li>将应用程序的每个实例退回一次</li>
<li>准备新部署的 0.11.0.3 应用程序实例以进行第二轮滚动反弹；确保删除 config 的值<code>upgrade.from</code></li>
<li>再次弹跳应用程序的每个实例以完成升级</li>
</ul>
</li>
<li>从0.10.0.x升级到0.11.0.0、0.11.0.1或0.11.0.2需要离线升级（不支持滚动弹跳升级）<ul>
<li>停止所有旧的（0.10.0.x）应用程序实例</li>
<li>更新您的代码并将旧代码和 jar 文件替换为新代码和新 jar 文件</li>
<li>重新启动所有新的（0.11.0.0、0.11.0.1 或 0.11.0.2）应用程序实例</li>
</ul>
</li>
</ul>
<h4 id="01103">0.11.0.3 中的显着变化</h4>
<ul>
<li>添加了新的 Kafka Streams 配置参数<code>upgrade.from</code>，允许从版本 0.10.0.x 滚动弹跳升级</li>
<li>有关此新配置的详细信息， 请参阅<a href="https://kafka.apache.org/35/documentation/streams/upgrade-guide.html"><strong>Kafka Streams 升级指南。</strong></a></li>
</ul>
<h4 id="01100">0.11.0.0 中的显着变化</h4>
<ul>
<li>现在默认禁用不干净的领导者选举。新的默认设置更注重持久性而不是可用性。希望保留以前行为的用户应将代理配置设置<code>unclean.leader.election.enable</code>为<code>true</code>。</li>
<li>生产者配置<code>block.on.buffer.full</code>和<code>metadata.fetch.timeout.ms</code>已<code>timeout.ms</code>被删除。它们最初在 Kafka 0.9.0.0 中被弃用。</li>
<li><code>offsets.topic.replication.factor</code>现在，在自动创建主题时强制执行代理配置。内部自动主题创建将失败并出现 GROUP_COORDINATOR_NOT_AVAILABLE 错误，直到集群大小满足此复制因子要求。</li>
<li>使用 snappy 压缩数据时，生产者和代理将使用压缩方案的默认块大小 (2 x 32 KB) 而不是 1 KB，以提高压缩率。有报告称，使用较小块大小压缩的数据比使用较大块大小压缩时大 50%。对于快速的情况，具有 5000 个分区的生产者将需要额外的 315 MB JVM 堆。</li>
<li>同样，当使用 gzip 压缩数据时，生产者和代理将使用 8 KB 而不是 1 KB 作为缓冲区大小。gzip 的默认值过低（512 字节）。</li>
<li>代理配置<code>max.message.bytes</code>现在适用于一批消息的总大小。以前，该设置应用于批量压缩消息，或单独应用于非压缩消息。消息批可能仅包含单个消息，因此在大多数情况下，对单个消息的大小的限制仅通过批处理格式的开销来减少。然而，消息格式转换有一些微妙的含义（更多详细信息请参见<a href="https://kafka.apache.org/documentation/#upgrade_11_message_format">下文）。</a>另请注意，虽然以前代理将确保每个提取请求中至少返回一条消息（无论总提取大小和分区级别提取大小如何），但现在相同的行为适用于一批消息。</li>
<li>默认启用 GC 日志轮换，详细信息请参阅 KAFKA-3754。</li>
<li>RecordMetadata、MetricName 和 Cluster 类已弃用的构造函数已被删除。</li>
<li>通过提供用户标头读写访问的新标头接口添加了用户标头支持。</li>
<li><code>Headers headers()</code>ProducerRecord 和 ConsumerRecord 通过方法调用公开新的 Headers API 。</li>
<li>引入了 ExtendedSerializer 和 ExtendedDeserializer 接口来支持标头的序列化和反序列化。如果配置的序列化器和反序列化器不是上述类，则标头将被忽略。</li>
<li><code>group.initial.rebalance.delay.ms</code>引入了新配置。<code>GroupCoordinator</code>此配置指定延迟初始消费者重新平衡的时间（以毫秒为单位） 。当新成员加入该组时，重新平衡将进一步延迟 的值<code>group.initial.rebalance.delay.ms</code>，最多为<code>max.poll.interval.ms</code>。默认值为 3 秒。在开发和测试期间，可能需要将其设置为 0，以免延迟测试执行时间。</li>
<li><code>org.apache.kafka.common.Cluster#partitionsForTopic</code>，<code>partitionsForNode</code>并且<code>availablePartitionsForTopic</code>方法将返回一个空列表<code>null</code>（这被认为是一种不好的做法），以防所需主题的元数据不存在。</li>
<li>Streams API 配置参数<code>timestamp.extractor</code>、<code>key.serde</code>和<code>value.serde</code>已弃用并分别替换为<code>default.timestamp.extractor</code>、<code>default.key.serde</code>和<code>default.value.serde</code>。</li>
<li>对于 Java 使用者 API 中的偏移提交失败，当 的实例传递给提交回调<code>commitAsync</code>时，我们不再公开根本原因。 有关更多详细信息， <code>RetriableCommitFailedException</code>请参阅 <a href="https://issues.apache.org/jira/browse/KAFKA-5052">KAFKA-5052 。</a></li>
</ul>
<h4 id="_16">新协议版本</h4>
<ul>
<li><a href="https://cwiki.apache.org/confluence/display/KAFKA/KIP-107%3A+Add+purgeDataBefore()+API+in+AdminClient">KIP-107</a>：FetchRequest v5 引入了分区级<code>log_start_offset</code>字段。</li>
<li><a href="https://cwiki.apache.org/confluence/display/KAFKA/KIP-107%3A+Add+purgeDataBefore()+API+in+AdminClient">KIP-107</a>：FetchResponse v5 引入了分区级<code>log_start_offset</code>字段。</li>
<li><a href="https://cwiki.apache.org/confluence/display/KAFKA/KIP-82+-+Add+Record+Headers">KIP-82</a><code>header</code> ：ProduceRequest v3在消息协议中引入了一个数组，包含<code>key</code>field和<code>value</code>field。</li>
<li><a href="https://cwiki.apache.org/confluence/display/KAFKA/KIP-82+-+Add+Record+Headers">KIP-82</a><code>header</code> ：FetchResponse v5在消息协议中引入了一个数组，包含<code>key</code>字段和<code>value</code>字段。</li>
</ul>
<h4 id="exactly-once">关于 Exactly Once 语义的注释</h4>
<p>Kafka 0.11.0 支持生产者中的幂等和事务功能。幂等传递可确保在单个生产者的生命周期内将消息恰好传递到特定主题分区一次。事务传递允许生产者将数据发送到多个分区，以便所有消息都成功传递，或者没有消息成功传递。这些功能共同实现了 Kafka 中的“恰好一次语义”。用户指南中提供了有关这些功能的更多详细信息，但下面我们添加了一些有关在升级的集群中启用这些功能的具体说明。请注意，启用 EoS 不是必需的，并且如果不使用，也不会影响代理的行为。</p>
<ol>
<li>只有新的 Java 生产者和消费者支持 Exactly Once 语义。</li>
<li>这些功能主要取决于<a href="https://kafka.apache.org/documentation/#upgrade_11_message_format">0.11.0 消息格式</a>。尝试在旧格式上使用它们将导致版本不受支持的错误。</li>
<li>事务状态存储在新的内部主题中<code>__transaction_state</code>。直到第一次尝试使用事务请求 API 时才会创建此主题。与消费者偏移量主题类似，有几个设置可以控制主题的配置。例如，<code>transaction.state.log.min.isr</code>控制该主题的最小 ISR。有关选项的完整列表，请参阅用户指南中的配置部分。</li>
<li>对于安全集群，事务 API 需要新的 ACL，可以使用<code>bin/kafka-acls.sh</code>. 工具。</li>
<li>Kafka 中的 EoS 引入了新的请求 API 并修改了多个现有 API。 有关完整详细信息，请参阅 <a href="https://cwiki.apache.org/confluence/display/KAFKA/KIP-98+-+Exactly+Once+Delivery+and+Transactional+Messaging#KIP-98-ExactlyOnceDeliveryandTransactionalMessaging-RPCProtocolSummary">KIP-98</a></li>
</ol>
<h4 id="0110">关于 0.11.0 中新消息格式的说明</h4>
<p>0.11.0 消息格式包括几个主要增强功能，以便支持生产者更好的传递语义（请参阅<a href="https://cwiki.apache.org/confluence/display/KAFKA/KIP-98+-+Exactly+Once+Delivery+and+Transactional+Messaging">KIP-98</a>）和改进的复制容错能力（请参阅<a href="https://cwiki.apache.org/confluence/display/KAFKA/KIP-101+-+Alter+Replication+Protocol+to+use+Leader+Epoch+rather+than+High+Watermark+for+Truncation">KIP-101</a>）。尽管新格式包含更多信息以使这些改进成为可能，但我们已经使批处理格式更加高效。只要每批次的消息数量超过 2，您就可以预期较低的总体开销。然而，对于较小的批次，可能会对性能产生较小的影响。请参阅<a href="https://kafka.apache.org/documentation/bit.ly/kafka-eos-perf">此处，</a>了解我们对新消息格式的初始性能分析的结果。<a href="https://cwiki.apache.org/confluence/display/KAFKA/KIP-98+-+Exactly+Once+Delivery+and+Transactional+Messaging#KIP-98-ExactlyOnceDeliveryandTransactionalMessaging-MessageFormat">您还可以在KIP-98</a>提案中找到有关消息格式的更多详细信息 。</p>
<p>新消息格式的显着差异之一是，即使未压缩的消息也会作为单个批次存储在一起。这对代理配置有一些影响<code>max.message.bytes</code>，它限制了单个批次的大小。首先，如果较旧的客户端使用旧格式向主题分区生成消息，并且这些消息各自小于 <code>max.message.bytes</code>，则在上转换过程中将它们合并为单个批次后，代理可能仍会拒绝它们。通常，当单个消息的总大小大于 时，就会发生这种情况<code>max.message.bytes</code>。对于旧消费者读取从新格式向下转换的消息，也会产生类似的效果：如果提取大小未设置为至少与 <code>max.message.bytes</code>，即使单个未压缩消息小于配置的获取大小，消费者也可能无法取得进展。此行为不会影响 0.10.1.0 及更高版本的 Java 客户端，因为它使用更新的获取协议，该协议确保即使超过获取大小也可以返回至少一条消息。为了解决这些问题，您应该确保 1) 生产者的批量大小设置不大于<code>max.message.bytes</code>，2) 消费者的获取大小设置至少与 一样大<code>max.message.bytes</code>。</p>
<p><a href="https://kafka.apache.org/documentation/#upgrade_10_performance_impact">大多数关于升级到 0.10.0 消息格式</a>对性能影响的讨论 仍然与 0.11.0 升级有关。这主要影响未使用 TLS 保护的集群，因为在这种情况下“零复制”传输已经不可能。为了避免降频转换的成本，您应该确保消费者应用程序升级到最新的 0.11.0 客户端。值得注意的是，由于旧的消费者在 0.11.0.0 中已被弃用，因此它不支持新的消息格式。您必须升级才能使用新的消费者才能使用新的消息格式，而无需进行下转换的成本。请注意，0.11.0 消费者支持向后兼容 0.10.0 代理及向上版本，因此可以在代理之前先升级客户端。</p>
<h3 id="08x09x0100x-0101x-01020">从 0.8.x、0.9.x、0.10.0.x 或 0.10.1.x 升级到 0.10.2.0</h3>
<p>0.10.2.0 进行了有线协议更改。通过遵循下面推荐的滚动升级计划，您可以保证升级期间不会出现停机。不过，请在升级之前查看<a href="https://kafka.apache.org/documentation/#upgrade_1020_notable">0.10.2.0 中的显着变化</a>。</p>
<p>从版本 0.10.2 开始，Java 客户端（生产者和消费者）已经获得了与旧代理进行通信的能力。版本 0.10.2 客户端可以与版本 0.10.0 或更高版本的代理进行通信。但是，如果您的代理低于 0.10.0，则必须在升级客户端之前升级 Kafka 集群中的所有代理。版本 0.10.2 代理支持 0.8.x 及更高版本的客户端。</p>
<p><strong>对于滚动升级：</strong></p>
<ol>
<li>更新所有代理上的 server.properties 文件并添加以下属性：<ul>
<li>inter.broker.protocol.version=CURRENT_KAFKA_VERSION（例如0.8.2、0.9.0、0.10.0或0.10.1）。</li>
<li>log.message.format.version=CURRENT_KAFKA_VERSION（有关此配置的详细信息， 请参阅<a href="https://kafka.apache.org/documentation/#upgrade_10_performance_impact">升级后的潜在性能影响。）</a></li>
</ul>
</li>
<li>一次升级一个代理：关闭代理，更新代码，然后重新启动。</li>
<li>整个集群升级后，通过编辑 inter.broker.protocol.version 并将其设置为 0.10.2 来提升协议版本。</li>
<li>如果您以前的消息格式是 0.10.0，请将 log.message.format.version 更改为 0.10.2（这是无操作，因为 0.10.0、0.10.1 和 0.10.2 的消息格式相同）。如果您之前的消息格式版本低于 0.10.0，请不要更改 log.message.format.version - 只有在所有使用者升级到 0.10.0.0 或更高版本后，此参数才应更改。</li>
<li>一一重启broker，新协议版本即可生效。</li>
<li>如果此时 log.message.format.version 仍然低于 0.10.0，请等到所有消费者都升级到 0.10.0 或更高版本，然后在每个代理上将 log.message.format.version 更改为 0.10.2 并将它们一一重新启动。</li>
</ol>
<p><strong>注意：</strong>如果您愿意接受停机，您只需关闭所有代理，更新代码并启动所有代理即可。默认情况下，他们将从新协议开始。</p>
<p><strong>注意：</strong>在代理升级后，可以随时更改协议版本并重新启动。它不一定是紧随其后。</p>
<h4 id="0101-kafka-streams_2">升级 0.10.1 Kafka Streams 应用程序</h4>
<ul>
<li>将 Streams 应用程序从 0.10.1 升级到 0.10.2 不需要代理升级。Kafka Streams 0.10.2 应用程序可以连接到 0.10.2 和 0.10.1 代理（但无法连接到 0.10.0 代理）。</li>
<li>您需要重新编译您的代码。仅交换 Kafka Streams 库 jar 文件是行不通的，并且会破坏您的应用程序。</li>
<li>如果您使用自定义（即用户实现的）时间戳提取器，您将需要更新此代码，因为接口<code>TimestampExtractor</code>已更改。</li>
<li>如果您注册自定义指标，则需要更新此代码，因为<code>StreamsMetric</code>界面已更改。</li>
<li>有关更多详细信息，请参阅<a href="https://kafka.apache.org/35/documentation/streams/upgrade-guide#streams_api_changes_0102">0.10.2 中的 Streams API 更改。</a></li>
</ul>
<h4 id="0100-kafka-streams_2">升级 0.10.0 Kafka Streams 应用程序</h4>
<ul>
<li>将 Streams 应用程序从 0.10.0 升级到 0.10.2 确实需要<a href="https://kafka.apache.org/documentation/#upgrade_10_1">代理升级</a>，因为 Kafka Streams 0.10.2 应用程序只能连接到 0.10.2 或 0.10.1 代理。</li>
<li>有一些 API 更改不向后兼容（请参阅<a href="https://kafka.apache.org/35/documentation/streams#streams_api_changes_0102">0.10.2 中的 Streams API 更改</a>以了解更多详细信息）。因此，您需要更新并重新编译代码。仅交换 Kafka Streams 库 jar 文件是行不通的，并且会破坏您的应用程序。</li>
<li>从 0.10.0.x 升级到 0.10.2.2 需要两次滚动反弹，并<code>upgrade.from="0.10.0"</code>为第一个升级阶段设置配置（参见<a href="https://cwiki.apache.org/confluence/display/KAFKA/KIP-268%3A+Simplify+Kafka+Streams+Rebalance+Metadata+Upgrade">KIP-268</a>）。作为替代方案，也可以进行离线升级。<ul>
<li>准备应用程序实例以进行滚动反弹，并确保将配置<code>upgrade.from</code>设置<code>"0.10.0"</code>为新版本 0.10.2.2</li>
<li>将应用程序的每个实例退回一次</li>
<li>为新部署的 0.10.2.2 应用程序实例做好第二轮滚动反弹的准备；确保删除 config 的值<code>upgrade.from</code></li>
<li>再次弹跳应用程序的每个实例以完成升级</li>
</ul>
</li>
<li>从0.10.0.x升级到0.10.2.0或0.10.2.1需要离线升级（不支持滚动弹跳升级）<ul>
<li>停止所有旧的（0.10.0.x）应用程序实例</li>
<li>更新您的代码并将旧代码和 jar 文件替换为新代码和新 jar 文件</li>
<li>重新启动所有新的（0.10.2.0 或 0.10.2.1）应用程序实例</li>
</ul>
</li>
</ul>
<h4 id="01022">0.10.2.2 中的显着变化</h4>
<ul>
<li>添加了新的配置参数<code>upgrade.from</code>，允许从版本 0.10.0.x 滚动弹跳升级</li>
</ul>
<h4 id="01021">0.10.2.1 中的显着变化</h4>
<ul>
<li>StreamsConfig 类的两个配置的默认值已更改，以提高 Kafka Streams 应用程序的弹性。内部 Kafka Streams 生产者<code>retries</code>默认值从 0 更改为 10。内部 Kafka Streams 消费者<code>max.poll.interval.ms</code> 默认值从 300000 更改为<code>Integer.MAX_VALUE</code>。</li>
</ul>
<h4 id="01020">0.10.2.0 中的显着变化</h4>
<ul>
<li>Java 客户端（生产者和消费者）已经获得了与旧代理进行通信的能力。版本 0.10.2 客户端可以与版本 0.10.0 或更高版本的代理进行通信。请注意，使用较旧的代理时，某些功能不可用或受到限制。</li>
<li><code>InterruptException</code>如果调用线程被中断，Java 使用者上的多个方法现在可能会抛出异常。请参阅<code>KafkaConsumer</code>Javadoc 以获取有关此更改的更深入的说明。</li>
<li>Java 消费者现在正常关闭。默认情况下，使用者最多等待 30 秒才能完成待处理的请求。添加了一个带有超时的新关闭 API<code>KafkaConsumer</code>以控制最大等待时间。</li>
<li>可以通过 --whitelist 选项将多个以逗号分隔的正则表达式传递给新 Java 使用者的 MirrorMaker。这使得使用旧的 Scala 消费者时的行为与 MirrorMaker 一致。</li>
<li>将 Streams 应用程序从 0.10.1 升级到 0.10.2 不需要代理升级。Kafka Streams 0.10.2 应用程序可以连接到 0.10.2 和 0.10.1 代理（但无法连接到 0.10.0 代理）。</li>
<li>Zookeeper 依赖项已从 Streams API 中删除。Streams API现在使用Kafka协议来管理内部主题，而不是直接修改Zookeeper。这消除了直接访问 Zookeeper 的权限的需要，并且不应再在 Streams 应用程序中设置“StreamsConfig.ZOOKEEPER_CONFIG”。如果 Kafka 集群受到保护，Streams 应用程序必须具有创建新主题所需的安全权限。</li>
<li>StreamsConfig 类中添加了几个新字段，包括“security.protocol”、“connections.max.idle.ms”、“retry.backoff.ms”、“reconnect.backoff.ms”和“request.timeout.ms”。用户应注意默认值并根据需要进行设置。更多详细信息请参考<a href="https://kafka.apache.org/35/documentation/#streamsconfigs">3.5 Kafka Streams配置</a>。</li>
</ul>
<h4 id="_17">新协议版本</h4>
<ul>
<li><a href="https://cwiki.apache.org/confluence/display/KAFKA/KIP-88%3A+OffsetFetch+Protocol+Update">KIP-88</a><code>topics</code> ：如果数组设置为 ，OffsetFetchRequest v2 支持检索所有主题的偏移量<code>null</code>。</li>
<li><a href="https://cwiki.apache.org/confluence/display/KAFKA/KIP-88%3A+OffsetFetch+Protocol+Update">KIP-88</a>：OffsetFetchResponse v2 引入了一个顶级<code>error_code</code>字段。</li>
<li><a href="https://cwiki.apache.org/confluence/display/KAFKA/KIP-103%3A+Separation+of+Internal+and+External+traffic">KIP-103</a>：UpdateMetadataRequest v3<code>listener_name</code>向数组元素引入了一个字段<code>end_points</code>。</li>
<li><a href="https://cwiki.apache.org/confluence/display/KAFKA/KIP-108%3A+Create+Topic+Policy">KIP-108</a>：CreateTopicsRequest v1 引入了一个<code>validate_only</code>字段。</li>
<li><a href="https://cwiki.apache.org/confluence/display/KAFKA/KIP-108%3A+Create+Topic+Policy">KIP-108</a>：CreateTopicsResponse v1<code>error_message</code>向数组元素引入了一个字段<code>topic_errors</code>。</li>
</ul>
<h3 id="08x09x-0100x-01010">从 0.8.x、0.9.x 或 0.10.0.X 升级到 0.10.1.0</h3>
<p>0.10.1.0 进行了有线协议更改。通过遵循下面推荐的滚动升级计划，您可以保证升级期间不会出现停机。但是，请在升级之前注意<a href="https://kafka.apache.org/documentation/#upgrade_10_1_breaking">0.10.1.0 中的潜在重大更改</a>。<br />
注意：由于引入了新协议，因此在升级客户端之前升级 Kafka 集群非常重要（即 0.10.1.x 客户端仅支持 0.10.1.x 或更高版本的代理，而 0.10.1.x 代理也支持旧客户端） 。</p>
<p><strong>对于滚动升级：</strong></p>
<ol>
<li>更新所有代理上的 server.properties 文件并添加以下属性：<ul>
<li>inter.broker.protocol.version=CURRENT_KAFKA_VERSION（例如0.8.2.0、0.9.0.0或0.10.0.0）。</li>
<li>log.message.format.version=CURRENT_KAFKA_VERSION（有关此配置的详细信息， 请参阅<a href="https://kafka.apache.org/documentation/#upgrade_10_performance_impact">升级后的潜在性能影响。）</a></li>
</ul>
</li>
<li>一次升级一个代理：关闭代理，更新代码，然后重新启动。</li>
<li>整个集群升级后，通过编辑 inter.broker.protocol.version 并将其设置为 0.10.1.0 来提升协议版本。</li>
<li>如果您以前的消息格式是 0.10.0，请将 log.message.format.version 更改为 0.10.1（这是无操作，因为 0.10.0 和 0.10.1 的消息格式相同）。如果您之前的消息格式版本低于 0.10.0，请不要更改 log.message.format.version - 只有在所有使用者升级到 0.10.0.0 或更高版本后，此参数才应更改。</li>
<li>一一重启broker，新协议版本即可生效。</li>
<li>如果此时 log.message.format.version 仍然低于 0.10.0，请等到所有消费者都升级到 0.10.0 或更高版本，然后在每个代理上将 log.message.format.version 更改为 0.10.1 并将它们一一重新启动。</li>
</ol>
<p><strong>注意：</strong>如果您愿意接受停机，您只需关闭所有代理，更新代码并启动所有代理即可。默认情况下，他们将从新协议开始。</p>
<p><strong>注意：</strong>在代理升级后，可以随时更改协议版本并重新启动。它不一定是紧随其后。</p>
<h4 id="01012">0.10.1.2 中的显着变化</h4>
<ul>
<li>添加了新的配置参数<code>upgrade.from</code>，允许从版本 0.10.0.x 滚动弹跳升级</li>
</ul>
<h4 id="01010">0.10.1.0 中潜在的重大变化</h4>
<ul>
<li>日志保留时间不再基于日志段的最后修改时间。相反，它将基于日志段中消息的最大时间戳。</li>
<li>日志滚动时间不再取决于日志段创建时间。相反，它现在基于消息中的时间戳。进一步来说。如果段中第一条消息的时间戳为T，则当新消息的时间戳大于或等于T + log.roll.ms时，日志将被转出</li>
<li>由于每个段增加了时间索引文件，0.10.0 的打开文件处理程序将增加约 33%。</li>
<li>时间索引和偏移索引共享相同的索引大小配置。由于每次索引条目的大小是偏移索引条目大小的 1.5 倍。用户可能需要增加 log.index.size.max.bytes 以避免潜在的频繁日志滚动。</li>
<li>由于索引文件数量的增加，在一些日志段数量较大（例如&gt;15K）的broker上，broker启动期间的日志加载过程可能会更长。根据我们的实验，将 num.recovery.threads.per.data.dir 设置为 1 可能会减少日志加载时间。</li>
</ul>
<h4 id="0100-kafka-streams_3">升级 0.10.0 Kafka Streams 应用程序</h4>
<ul>
<li>将 Streams 应用程序从 0.10.0 升级到 0.10.1 确实需要<a href="https://kafka.apache.org/documentation/#upgrade_10_1">代理升级</a>，因为 Kafka Streams 0.10.1 应用程序只能连接到 0.10.1 代理。</li>
<li>有一些 API 更改不向后兼容（请参阅<a href="https://kafka.apache.org/35/documentation/streams/upgrade-guide#streams_api_changes_0101">0.10.1 中的 Streams API 更改</a>以了解更多详细信息）。因此，您需要更新并重新编译代码。仅交换 Kafka Streams 库 jar 文件是行不通的，并且会破坏您的应用程序。</li>
<li>从 0.10.0.x 升级到 0.10.1.2 需要两次滚动反弹，并<code>upgrade.from="0.10.0"</code>为第一个升级阶段设置配置（参见<a href="https://cwiki.apache.org/confluence/display/KAFKA/KIP-268%3A+Simplify+Kafka+Streams+Rebalance+Metadata+Upgrade">KIP-268</a>）。作为替代方案，也可以进行离线升级。<ul>
<li>准备应用程序实例以进行滚动反弹，并确保将配置<code>upgrade.from</code>设置<code>"0.10.0"</code>为新版本 0.10.1.2</li>
<li>将应用程序的每个实例退回一次</li>
<li>准备新部署的 0.10.1.2 应用程序实例以进行第二轮滚动反弹；确保删除 config 的值<code>upgrade.from</code></li>
<li>再次弹跳应用程序的每个实例以完成升级</li>
</ul>
</li>
<li>从0.10.0.x升级到0.10.1.0或0.10.1.1需要离线升级（不支持滚动弹跳升级）<ul>
<li>停止所有旧的（0.10.0.x）应用程序实例</li>
<li>更新您的代码并将旧代码和 jar 文件替换为新代码和新 jar 文件</li>
<li>重新启动所有新的（0.10.1.0 或 0.10.1.1）应用程序实例</li>
</ul>
</li>
</ul>
<h4 id="01010_1">0.10.1.0 中的显着变化</h4>
<ul>
<li>新的 Java 消费者不再处于测试阶段，我们建议将其用于所有新开发。旧的 Scala 使用者仍然受支持，但它们将在下一个版本中弃用，并在未来的主要版本中删除。</li>
<li>在新消费者中使用 MirrorMaker 和 Console Consumer 等工具时不再需要<code>--new-consumer</code>/开关；<code>--new.consumer</code>只需要通过 Kafka 代理来连接即可，而不是通过 ZooKeeper 整体进行连接。此外，控制台消费者与旧消费者的使用已被弃用，并将在未来的主要版本中删除。</li>
<li>Kafka 集群现在可以通过集群 ID 来唯一标识。当broker升级到0.10.1.0时，它将自动生成。集群 ID 可通过 kafka.server:type=KafkaServer,name=ClusterId 指标获得，它是元数据响应的一部分。序列化器、客户端拦截器和指标报告器可以通过实现 ClusterResourceListener 接口来接收集群 ID。</li>
<li>BrokerState“RunningAsController”（值 4）已被删除。由于存在错误，代理在退出该状态之前只会短暂处于此状态，因此删除的影响应该很小。检测给定代理是否是控制器的推荐方法是通过 kafka.controller:type=KafkaController,name=ActiveControllerCount 指标。</li>
<li>新的 Java Consumer 现在允许用户按分区上的时间戳搜索偏移量。</li>
<li>新的 Java Consumer 现在支持后台线程的心跳。有一个新配置 <code>max.poll.interval.ms</code>可以控制消费者主动离开组之前轮询调用之间的最长时间（默认情况下为 5 分钟）。配置值 <code>request.timeout.ms</code>（默认为 30 秒）必须始终小于<code>max.poll.interval.ms</code>（默认为 5 分钟），因为这是消费者重新平衡时 JoinGroup 请求可以在服务器上阻塞的最长时间。最后，默认值<code>session.timeout.ms</code>调整为10秒，默认值<code>max.poll.records</code>改为500。</li>
<li>当使用授权者并且用户没有主题的描述授权时，代理将不再向请求返回 TOPIC_AUTHORIZATION_FAILED 错误，因为这会泄漏主题名称<strong>。</strong>相反，将返回 UNKNOWN_TOPIC_OR_PARTITION 错误代码。在使用生产者和消费者时，这可能会导致意外超时或延迟，因为 Kafka 客户端通常会针对未知主题错误自动重试。如果您怀疑可能发生这种情况，您应该查阅客户端日志。</li>
<li>默认情况下，获取响应有大小限制（消费者为 50 MB，复制为 10 MB）。现有的每个分区限制也适用（使用者和复制为 1 MB）。请注意，这些限制都不是绝对最大值，如下一点所述。</li>
<li>如果发现大于响应/分区大小限制的消息，使用者和副本可以取得进展。更具体地说，如果提取的第一个非空分区中的第一条消息大于其中一个或两个限制，则仍将返回该消息。</li>
<li>添加了重载的构造函数<code>kafka.api.FetchRequest</code>，并<code>kafka.javaapi.FetchRequest</code>允许调用者指定分区的顺序（因为顺序在 v3 中很重要）。以前存在的构造函数已被弃用，并且在发送请求之前会对分区进行洗牌以避免饥饿问题。</li>
</ul>
<h4 id="_18">新协议版本</h4>
<ul>
<li>ListOffsetRequest v1支持基于时间戳的精确偏移搜索。</li>
<li>MetadataResponse v2 引入了一个新字段：“cluster_id”。</li>
<li>FetchRequest v3 支持限制响应大小（除了现有的每个分区限制），如果需要取得进展，它会返回大于限制的消息，并且请求中的分区顺序现在很重要。</li>
<li>JoinGroup v1 引入了一个新字段：“rebalance_timeout”。</li>
</ul>
<h3 id="08x-09x-01000">从 0.8.x 或 0.9.x 升级到 0.10.0.0</h3>
<p>0.10.0.0 具有<a href="https://kafka.apache.org/documentation/#upgrade_10_breaking">潜在的重大更改</a>（请在升级前查看），并且 <a href="https://kafka.apache.org/documentation/#upgrade_10_performance_impact">升级后可能会影响性能</a>。通过遵循下面推荐的滚动升级计划，您可以保证升级期间和升级后不会出现停机且不会影响性能。<br />
注意：由于引入了新协议，因此在升级客户端之前升级 Kafka 集群非常重要。</p>
<p><strong>版本 0.9.0.0 的客户端注意事项：</strong>由于 0.9.0.0 中引入的错误，依赖 ZooKeeper（旧的 Scala 高级 Consumer 和 MirrorMaker，如果与旧的 Consumer 一起使用）的客户端将无法与 0.10.0.x 代理一起使用。因此，在代理升级到0.10.0.x<strong>之前，</strong> 0.9.0.0客户端应升级到0.9.0.1。对于 0.8.X 或 0.9.0.1 客户端，无需执行此步骤。</p>
<p><strong>对于滚动升级：</strong></p>
<ol>
<li>更新所有代理上的 server.properties 文件并添加以下属性：<ul>
<li>inter.broker.protocol.version=CURRENT_KAFKA_VERSION（例如0.8.2或0.9.0.0）。</li>
<li>log.message.format.version=CURRENT_KAFKA_VERSION（有关此配置的详细信息， 请参阅<a href="https://kafka.apache.org/documentation/#upgrade_10_performance_impact">升级后的潜在性能影响。）</a></li>
</ul>
</li>
<li>升级broker。只需将代理关闭、更新代码并重新启动即可一次完成此操作。</li>
<li>整个集群升级后，通过编辑 inter.broker.protocol.version 并将其设置为 0.10.0.0 来提升协议版本。注意：您还不应该触摸 log.message.format.version - 只有在所有使用者都升级到 0.10.0.0 后，此参数才应更改</li>
<li>一一重启broker，新协议版本即可生效。</li>
<li>所有消费者升级到 0.10.0 后，将每个代理上的 log.message.format.version 更改为 0.10.0 并一一重新启动它们。</li>
</ol>
<p><strong>注意：</strong>如果您愿意接受停机，您只需关闭所有代理，更新代码并启动所有代理即可。默认情况下，他们将从新协议开始。</p>
<p><strong>注意：</strong>在代理升级后，可以随时更改协议版本并重新启动。它不一定是紧随其后。</p>
<h4 id="01000">升级到 0.10.0.0 后的潜在性能影响</h4>
<p>0.10.0 中的消息格式包括一个新的时间戳字段，并使用压缩消息的相对偏移量。磁盘消息格式可以通过 server.properties 文件中的 log.message.format.version 配置。默认磁盘消息格式为 0.10.0。如果消费者客户端使用的是 0.10.0.0 之前的版本，则它只能理解 0.10.0 之前的消息格式。在这种情况下，代理能够将消息从 0.10.0 格式转换为较早的格式，然后再将响应发送给旧版本的使用者。但是，在这种情况下，经纪商不能使用零拷贝传输。Kafka 社区关于性能影响的报告显示，升级后 CPU 利用率从之前的 20% 上升到 100%，这迫使所有客户端立即升级以使性能恢复正常。为了避免在消费者升级到 0.10.0.0 之前发生此类消息转换，可以在将代理升级到 0.10.0.0 时将 log.message.format.version 设置为 0.8.2 或 0.9.0。这样，broker仍然可以使用零拷贝传输将数据发送给旧的消费者。一旦消费者升级，就可以在代理上将消息格式更改为 0.10.0，并享受包括新时间戳和改进压缩的新消息格式。支持转换是为了确保兼容性，并且对于支持一些尚未更新到较新客户端的应用程序很有用，但即使在过度配置的集群上支持所有消费者流量也是不切实际的。因此，当代理已升级但大多数客户端尚未升级时，尽可能避免消息转换至关重要。将代理升级到 0.10.0.0 时，将 message.format.version 更改为 0.8.2 或 0.9.0。这样，broker仍然可以使用零拷贝传输将数据发送给旧的消费者。一旦消费者升级，就可以在代理上将消息格式更改为 0.10.0，并享受包括新时间戳和改进压缩的新消息格式。支持转换是为了确保兼容性，并且对于支持一些尚未更新到较新客户端的应用程序很有用，但即使在过度配置的集群上支持所有消费者流量也是不切实际的。因此，当代理已升级但大多数客户端尚未升级时，尽可能避免消息转换至关重要。将代理升级到 0.10.0.0 时，将 message.format.version 更改为 0.8.2 或 0.9.0。这样，broker仍然可以使用零拷贝传输将数据发送给旧的消费者。一旦消费者升级，就可以在代理上将消息格式更改为 0.10.0，并享受包括新时间戳和改进压缩的新消息格式。支持转换是为了确保兼容性，并且对于支持一些尚未更新到较新客户端的应用程序很有用，但即使在过度配置的集群上支持所有消费者流量也是不切实际的。因此，当代理已升级但大多数客户端尚未升级时，尽可能避免消息转换至关重要。Broker 仍然可以使用零拷贝传输将数据发送给旧消费者。一旦消费者升级，就可以在代理上将消息格式更改为 0.10.0，并享受包括新时间戳和改进压缩的新消息格式。支持转换是为了确保兼容性，并且对于支持一些尚未更新到较新客户端的应用程序很有用，但即使在过度配置的集群上支持所有消费者流量也是不切实际的。因此，当代理已升级但大多数客户端尚未升级时，尽可能避免消息转换至关重要。Broker 仍然可以使用零拷贝传输将数据发送给旧消费者。一旦消费者升级，就可以在代理上将消息格式更改为 0.10.0，并享受包括新时间戳和改进压缩的新消息格式。支持转换是为了确保兼容性，并且对于支持一些尚未更新到较新客户端的应用程序很有用，但即使在过度配置的集群上支持所有消费者流量也是不切实际的。因此，当代理已升级但大多数客户端尚未升级时，尽可能避免消息转换至关重要。支持转换是为了确保兼容性，并且对于支持一些尚未更新到较新客户端的应用程序很有用，但即使在过度配置的集群上支持所有消费者流量也是不切实际的。因此，当代理已升级但大多数客户端尚未升级时，尽可能避免消息转换至关重要。支持转换是为了确保兼容性，并且对于支持一些尚未更新到较新客户端的应用程序很有用，但即使在过度配置的集群上支持所有消费者流量也是不切实际的。因此，当代理已升级但大多数客户端尚未升级时，尽可能避免消息转换至关重要。</p>
<p>对于升级到 0.10.0.0 的客户端，不会产生性能影响。</p>
<p><strong>注意：</strong>通过设置消息格式版本，可以证明所有现有消息均等于或低于该消息格式版本。否则 0.10.0.0 之前的消费者可能会崩溃。特别是，在消息格式设置为 0.10.0 后，不应将其更改回较早的格式，因为这可能会破坏 0.10.0.0 之前版本的消费者。</p>
<p><strong>注意：</strong>由于每条消息中引入了额外的时间戳，发送小消息的生产者可能会因为开销增加而看到消息吞吐量下降。同样，复制现在每条消息额外传输 8 个字节。如果您的运行接近集群的网络容量，则可能会导致网卡不堪重负，并因过载而出现故障和性能问题。</p>
<p><strong>注意：</strong>如果您在生产者上启用了压缩，您可能会注意到在某些情况下生产者吞吐量降低和/或代理上的压缩率降低。接收压缩消息时，0.10.0 代理会避免重新压缩消息，这通常会减少延迟并提高吞吐量。然而，在某些情况下，这可能会减少生产者的批处理大小，从而导致吞吐量下降。如果发生这种情况，用户可以调整生产者的linger.ms和batch.size以获得更好的吞吐量。此外，snappy 用于压缩消息的生产者缓冲区小于代理使用的缓冲区，这可能会对磁盘上​​消息的压缩率产生负面影响。我们打算在未来的 Kafka 版本中对此进行配置。</p>
<h4 id="01000_1">0.10.0.0 中潜在的重大变化</h4>
<ul>
<li>从Kafka 0.10.0.0开始，Kafka中的消息格式版本以Kafka版本表示。例如，消息格式0.9.0是指Kafka 0.9.0支持的最高消息版本。</li>
<li>已引入消息格式 0.10.0，并且默认使用该格式。它在消息中包含时间戳字段，并且相对偏移量用于压缩消息。</li>
<li>引入ProduceRequest/Response v2，默认支持消息格式0.10.0</li>
<li>引入FetchRequest/Response v2，默认支持消息格式0.10.0</li>
<li>MessageFormatter 接口已更改<code>def writeTo(key: Array[Byte], value: Array[Byte], output: PrintStream)</code>为 <code>def writeTo(consumerRecord: ConsumerRecord[Array[Byte], Array[Byte]], output: PrintStream)</code></li>
<li>MessageReader 接口已更改<code>def readMessage(): KeyedMessage[Array[Byte], Array[Byte]]</code>为 <code>def readMessage(): ProducerRecord[Array[Byte], Array[Byte]]</code></li>
<li>MessageFormatter 的包已更改<code>kafka.tools</code>为<code>kafka.common</code></li>
<li>MessageReader 的包已更改<code>kafka.tools</code>为<code>kafka.common</code></li>
<li>MirrorMakerMessageHandler 不再公开该<code>handle(record: MessageAndMetadata[Array[Byte], Array[Byte]])</code>方法，因为它从未被调用。</li>
<li>0.7 KafkaMigrationTool 不再与 Kafka 一起打包。如果您需要从0.7迁移到0.10.0，请先迁移到0.8，然后按照记录的升级流程从0.8升级到0.10.0。</li>
<li>新的消费者已标准化其 API，以接受<code>java.util.Collection</code>作为方法参数的序列类型。现有代码可能需要更新才能与 0.10.0 客户端库一起使用。</li>
<li>LZ4 压缩消息处理已更改为使用可互操作的帧规范 (LZ4f v1.5.1)。为了保持与旧客户端的兼容性，此更改仅适用于消息格式 0.10.0 及更高版本。使用 v0/v1（消息格式 0.9.0）生成/获取 LZ4 压缩消息的客户端应继续使用 0.9.0 帧实现。使用 Produce/Fetch 协议 v2 或更高版本的客户端应使用可互操作的 LZ4f 帧。可互操作的 LZ4 库列表位于<a href="https://www.lz4.org/">https://www.lz4.org/</a></li>
</ul>
<h4 id="01000_2">0.10.0.0 中的显着变化</h4>
<ul>
<li><strong>从 Kafka 0.10.0.0 开始，一个名为Kafka Streams</strong>的新客户端库可用于对 Kafka 主题中存储的数据进行流处理。由于上述消息格式的变化，这个新的客户端库仅适用于 0.10.x 及更高版本的代理。有关更多信息，请阅读<a href="https://kafka.apache.org/35/documentation/streams">Streams 文档</a>。</li>
<li><code>receive.buffer.bytes</code>对于新消费者来说，配置参数的默认值现在是 64K。</li>
<li>新的消费者现在公开配置参数<code>exclude.internal.topics</code>以限制内部主题（例如消费者偏移主题）意外地包含在正则表达式订阅中。默认情况下，它是启用的。</li>
<li>旧的 Scala 生成器已被弃用。用户应尽快将其代码迁移到 kafka-clients JAR 中包含的 Java 生产者。</li>
<li>新的消费者 API 已标记为稳定。</li>
</ul>
<h3 id="080081x-082x-0900">从 0.8.0、0.8.1.X 或 0.8.2.X 升级到 0.9.0.0</h3>
<p>0.9.0.0 具有<a href="https://kafka.apache.org/documentation/#upgrade_9_breaking">潜在的重大更改</a>（请在升级前查看）以及与先前版本相比的经纪商间协议更改。这意味着升级后的经纪商和客户端可能与旧版本不兼容。在升级客户端之前升级 Kafka 集群非常重要。如果您使用 MirrorMaker，下游集群也应该首先升级。</p>
<p><strong>对于滚动升级：</strong></p>
<ol>
<li>更新所有代理上的 server.properties 文件并添加以下属性： inter.broker.protocol.version=0.8.2.X</li>
<li>升级broker。只需将代理关闭、更新代码并重新启动即可一次完成此操作。</li>
<li>整个集群升级后，通过编辑 inter.broker.protocol.version 并将其设置为 0.9.0.0 来提升协议版本。</li>
<li>一一重启broker，新协议版本生效</li>
</ol>
<p><strong>注意：</strong>如果您愿意接受停机，您只需关闭所有代理，更新代码并启动所有代理即可。默认情况下，他们将从新协议开始。</p>
<p><strong>注意：</strong>在代理升级后，可以随时更改协议版本并重新启动。它不一定是紧随其后。</p>
<h4 id="0900">0.9.0.0 中潜在的重大变化</h4>
<ul>
<li>不再支持 Java 1.6。</li>
<li>不再支持 Scala 2.9。</li>
<li>1000 以上的经纪商 ID 现在默认保留为自动分配的经纪商 ID。如果您的集群的现有代理 ID 高于该阈值，请确保相应地增加served.broker.max.id 代理配置属性。</li>
<li>配置参数replica.lag.max.messages已删除。分区领导者在决定哪些副本同步时将不再考虑滞后消息的数量。</li>
<li>配置参数replica.lag.time.max.ms现在不仅指自上次从副本获取请求以来经过的时间，还指自副本上次赶上以来的时间。仍在从领导者获取消息但未赶上replica.lag.time.max.ms 中最新消息的副本将被视为不同步。</li>
<li>压缩主题不再接受没有密钥的消息，如果尝试这样做，生产者会抛出异常。在 0.8.x 中，没有 key 的消息将导致日志压缩线程随后抱怨并退出（并停止压缩所有压缩主题）。</li>
<li>MirrorMaker 不再支持多个目标集群。因此，它只接受单个 --consumer.config 参数。要镜像多个源集群，每个源集群至少需要一个 MirrorMaker 实例，每个实例都有自己的使用者配置。</li>
<li><em>打包在org.apache.kafka.clients.tools.*</em>下的工具已移至<em>org.apache.kafka.tools.*</em>。所有包含的脚本仍将照常运行，只有直接导入这些类的自定义代码才会受到影响。</li>
<li>kafka-run-class.sh 中的默认 Kafka JVM 性能选项 (KAFKA_JVM_PERFORMANCE_OPTS) 已更改。</li>
<li>kafka-topics.sh 脚本 (kafka.admin.TopicCommand) 现在在失败时以非零退出代码退出。</li>
<li>当主题名称因使用“.”而存在指标冲突风险时，kafka-topics.sh 脚本 (kafka.admin.TopicCommand) 现在将打印警告 或主题名称中的“_”，并且在实际冲突的情况下出错。</li>
<li>kafka-console- Producer.sh脚本（kafka.tools.ConsoleProducer）将默认使用Java生产者而不是旧的Scala生产者，用户必须指定“old- Producer”才能使用旧生产者。</li>
<li>默认情况下，所有命令行工具都会将所有日志消息打印到 stderr 而不是 stdout。</li>
</ul>
<h4 id="0901">0.9.0.1 中的显着变化</h4>
<ul>
<li>可以通过将broker.id. Generation.enable 设置为 false 来禁用新的代理 ID 生成功能。</li>
<li>配置参数 log.cleaner.enable 现在默认为 true。这意味着具有 cleanup.policy=compact 的主题现在将默认进行压缩，并且 128 MB 的堆将通过 log.cleaner.dedupe.buffer.size 分配给清理进程。您可能需要根据压缩主题的使用情况查看 log.cleaner.dedupe.buffer.size 和其他 log.cleaner 配置值。</li>
<li>新消费者的配置参数 fetch.min.bytes 的默认值现在默认为 1。</li>
</ul>
<h4 id="0900_1">0.9.0.0 中的弃用</h4>
<ul>
<li>已弃用从 kafka-topics.sh 脚本 (kafka.admin.TopicCommand) 更改主题配置。今后，请使用 kafka-configs.sh 脚本 (kafka.admin.ConfigCommand) 来实现此功能。</li>
<li>kafka-consumer-offset-checker.sh (kafka.tools.ConsumerOffsetChecker) 已被弃用。今后，请使用 kafka-consumer-groups.sh (kafka.admin.ConsumerGroupCommand) 来实现此功能。</li>
<li>kafka.tools.ProducerPerformance 类已被弃用。今后，请使用 org.apache.kafka.tools.ProducerPerformance 来实现此功能（kafka- Producer-perf-test.sh 也将更改为使用新类）。</li>
<li>生产者配置 block.on.buffer.full 已被弃用，并将在未来版本中删除。目前其默认值已更改为 false。KafkaProducer将不再抛出BufferExhaustedException，而是使用max.block.ms值进行阻塞，之后它将抛出TimeoutException。如果 block.on.buffer.full 属性显式设置为 true，则会将 max.block.ms 设置为 Long.MAX_VALUE，并且metadata.fetch.timeout.ms 将不会被遵守</li>
</ul>
<h3 id="081082">从0.8.1升级到0.8.2</h3>
<p>0.8.2 与 0.8.1 完全兼容。只需将其关闭、更新代码并重新启动即可一次对一个代理进行升级。</p>
<h3 id="080081">从0.8.0升级到0.8.1</h3>
<p>0.8.1 与 0.8 完全兼容。只需将其关闭、更新代码并重新启动即可一次对一个代理进行升级。</p>
<h3 id="07">从0.7升级</h3>
<p>版本 0.7 与较新的版本不兼容。为了添加复制（0.7 中缺少），对 API、ZooKeeper 数据结构、协议和配置进行了重大更改。从0.7升级到更高版本需要<a href="https://cwiki.apache.org/confluence/display/KAFKA/Migrating+from+0.7+to+0.8">专门的</a>迁移工具。此迁移无需停机即可完成。</p></div>
            </div>
        </div>

        <footer class="col-md-12">
            <hr>
            <p>Documentation built with <a href="https://www.mkdocs.org/">MkDocs</a>.</p>
        </footer>
        <script src="../js/bootstrap.bundle.min.js"></script>
        <script>
            var base_url = "..",
                shortcuts = {"help": 191, "next": 78, "previous": 80, "search": 83};
        </script>
        <script src="../js/base.js"></script>
        <script src="https://polyfill.io/v3/polyfill.min.js?features=es6"></script>
        <script src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js"></script>
        <script src="../search/main.js"></script>

        <div class="modal" id="mkdocs_search_modal" tabindex="-1" role="dialog" aria-labelledby="searchModalLabel" aria-hidden="true">
    <div class="modal-dialog modal-lg">
        <div class="modal-content">
            <div class="modal-header">
                <h4 class="modal-title" id="searchModalLabel">Search</h4>
                <button type="button" class="btn-close" data-bs-dismiss="modal" aria-label="Close"></button>
            </div>
            <div class="modal-body">
                <p>From here you can search these documents. Enter your search terms below.</p>
                <form>
                    <div class="form-group">
                        <input type="search" class="form-control" placeholder="Search..." id="mkdocs-search-query" title="Type search term here">
                    </div>
                </form>
                <div id="mkdocs-search-results" data-no-results-text="No results found"></div>
            </div>
            <div class="modal-footer">
            </div>
        </div>
    </div>
</div><div class="modal" id="mkdocs_keyboard_modal" tabindex="-1" role="dialog" aria-labelledby="keyboardModalLabel" aria-hidden="true">
    <div class="modal-dialog">
        <div class="modal-content">
            <div class="modal-header">
                <h4 class="modal-title" id="keyboardModalLabel">Keyboard Shortcuts</h4>
                <button type="button" class="btn-close" data-bs-dismiss="modal" aria-label="Close"></button>
            </div>
            <div class="modal-body">
              <table class="table">
                <thead>
                  <tr>
                    <th style="width: 20%;">Keys</th>
                    <th>Action</th>
                  </tr>
                </thead>
                <tbody>
                  <tr>
                    <td class="help shortcut"><kbd>?</kbd></td>
                    <td>Open this help</td>
                  </tr>
                  <tr>
                    <td class="next shortcut"><kbd>n</kbd></td>
                    <td>Next page</td>
                  </tr>
                  <tr>
                    <td class="prev shortcut"><kbd>p</kbd></td>
                    <td>Previous page</td>
                  </tr>
                  <tr>
                    <td class="search shortcut"><kbd>s</kbd></td>
                    <td>Search</td>
                  </tr>
                </tbody>
              </table>
            </div>
            <div class="modal-footer">
            </div>
        </div>
    </div>
</div>

    </body>
</html>
